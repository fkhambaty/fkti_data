<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support Vector Machines (SVM) | Fakhruddin Khambaty's Learning Hub</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(160deg, #f5f0ff 0%, #ede4ff 25%, #e8f4fd 50%, #fdf2f8 75%, #f0f9ff 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            color: #1e293b;
            line-height: 2;
            font-size: 18px;
        }
        .container { max-width: 920px; margin: 0 auto; }

        .nav {
            background: rgba(255,255,255,0.65);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(168,85,247,0.12);
            padding: 15px 30px; border-radius: 18px; margin-bottom: 30px;
            box-shadow: 0 4px 24px rgba(147,51,234,0.06);
            display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;
        }
        .nav a { color: #7c3aed; text-decoration: none; font-weight: 600; display: flex; align-items: center; gap: 8px; transition: all .2s; }
        .nav a:hover { color: #6d28d9; transform: translateX(-2px); }

        .header {
            text-align: center; padding: 55px 40px;
            background: linear-gradient(135deg, #a855f7 0%, #8b5cf6 50%, #7c3aed 100%);
            border-radius: 28px; color: white; margin-bottom: 40px;
            box-shadow: 0 12px 40px rgba(139,92,246,0.25);
            position: relative; overflow: hidden;
        }
        .header::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
            animation: headerShine 8s ease-in-out infinite;
        }
        @keyframes headerShine { 0%,100%{transform:translate(0,0);} 50%{transform:translate(20px,10px);} }
        .header h1 { font-size: 2.6em; margin-bottom: 15px; font-weight: 900; position: relative; }
        .header p { font-size: 1.15em; opacity: 0.95; max-width: 700px; margin: 0 auto; position: relative; }
        .beginner-badge { background: #f59e0b; color: white; padding: 8px 20px; border-radius: 25px; font-weight: 700; display: inline-block; margin-bottom: 20px; font-size: 0.9em; position: relative; }

        .section {
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(18px); -webkit-backdrop-filter: blur(18px);
            border: 1px solid rgba(168,85,247,0.1);
            border-radius: 28px; padding: 45px; margin-bottom: 35px;
            box-shadow: 0 4px 30px rgba(139,92,246,0.05);
            transition: border-color .3s, box-shadow .3s;
        }
        .section:hover { border-color: rgba(168,85,247,0.22); box-shadow: 0 8px 40px rgba(139,92,246,0.08); }
        .section h2 { color: #7c3aed; font-size: 1.8em; margin-bottom: 25px; display: flex; align-items: center; gap: 15px; padding-bottom: 15px; border-bottom: 3px solid #ede9fe; }
        .section h3 { color: #6d28d9; font-size: 1.35em; margin: 35px 0 20px 0; padding-left: 20px; border-left: 5px solid #a78bfa; }
        .section p { font-size: 1.08em; color: #334155; margin-bottom: 18px; }

        .eli5-box {
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border: 2px dashed #f59e0b; border-radius: 20px; padding: 28px; margin: 25px 0;
        }
        .eli5-box h4 { color: #92400e; font-size: 1.25em; margin-bottom: 15px; }
        .eli5-box p { color: #78350f; font-size: 1.1em; margin-bottom: 10px; }

        .analogy-box {
            background: linear-gradient(135deg, #faf5ff, #f3e8ff);
            border-left: 5px solid #8b5cf6; border-radius: 20px; padding: 28px; margin: 25px 0;
        }
        .analogy-box h4 { color: #6d28d9; font-size: 1.2em; margin-bottom: 15px; }
        .analogy-box p, .analogy-box li { color: #4c1d95; }

        .key-point {
            background: linear-gradient(135deg, #f5f3ff, #ede9fe);
            border-left: 5px solid #8b5cf6; border-radius: 20px; padding: 25px; margin: 25px 0;
        }
        .key-point h4 { color: #6d28d9; margin-bottom: 12px; }
        .key-point ul { margin-left: 22px; color: #4c1d95; }
        .key-point li { margin-bottom: 8px; }

        .warning-box {
            background: linear-gradient(135deg, #fef2f2, #fee2e2);
            border: 2px solid #fca5a5; border-radius: 20px; padding: 25px; margin: 25px 0;
        }
        .warning-box h4 { color: #b91c1c; margin-bottom: 10px; }
        .warning-box p, .warning-box li { color: #991b1b; }

        .code-block {
            background: #1e293b; border-radius: 20px; padding: 28px; margin: 25px 0; overflow-x: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .code-block pre { margin: 0; font-family: 'Fira Code', monospace; font-size: 0.92em; color: #e2e8f0; line-height: 1.8; }
        .code-block .comment { color: #94a3b8; } .code-block .keyword { color: #c084fc; }
        .code-block .function { color: #38bdf8; } .code-block .string { color: #4ade80; }
        .code-block .number { color: #fb923c; }

        .data-table {
            width: 100%; border-collapse: collapse; margin: 25px 0;
            background: white; border-radius: 16px; overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
        }
        .data-table th { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 16px 15px; text-align: left; font-weight: 700; }
        .data-table td { padding: 14px 15px; border-bottom: 2px solid #f5f3ff; color: #334155; }
        .data-table tr:nth-child(even) { background: #faf5ff; }
        .data-table tr:hover td { background: #f3e8ff; }

        .step-card {
            display: flex; align-items: flex-start; gap: 20px;
            background: rgba(255,255,255,0.7); backdrop-filter: blur(10px);
            border: 1px solid #e9d5ff; padding: 22px 25px; border-radius: 16px; margin: 15px 0; transition: all .3s;
        }
        .step-card:hover { border-color: #a78bfa; transform: translateX(4px); box-shadow: 0 4px 15px rgba(139,92,246,0.08); }
        .step-num {
            width: 44px; height: 44px; background: linear-gradient(135deg, #a855f7, #7c3aed);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-weight: 700; color: white; flex-shrink: 0; box-shadow: 0 4px 12px rgba(139,92,246,0.25);
        }
        .step-card h5 { color: #6d28d9; font-size: 1.15em; margin-bottom: 6px; }
        .step-card p { color: #475569; margin: 0; font-size: 1em; }

        .svm-visual {
            background: rgba(255,255,255,0.5); backdrop-filter: blur(12px);
            border: 1px solid #e9d5ff; border-radius: 20px; padding: 30px; margin: 25px 0; text-align: center;
        }
        .svm-visual h4 { color: #7c3aed; margin-bottom: 15px; }
        .svm-visual svg { max-width: 100%; height: auto; }

        .nav-buttons { display: flex; justify-content: space-between; margin-top: 50px; gap: 20px; flex-wrap: wrap; }
        .nav-btn {
            display: inline-flex; align-items: center; gap: 10px;
            padding: 16px 32px; border-radius: 16px; text-decoration: none; font-weight: 700; transition: all 0.3s;
        }
        .nav-btn.prev { background: rgba(255,255,255,0.7); backdrop-filter: blur(10px); color: #475569; border: 1px solid #e2e8f0; }
        .nav-btn.next { background: linear-gradient(135deg, #a855f7, #7c3aed); color: white; box-shadow: 0 4px 20px rgba(139,92,246,0.25); }
        .nav-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.1); }

        .back-to-top { position: fixed; bottom: 30px; right: 30px; width: 55px; height: 55px; background: linear-gradient(135deg, #a855f7, #7c3aed); color: white; border: none; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 22px; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; box-shadow: 0 4px 20px rgba(139,92,246,0.3); }
        .back-to-top.show { opacity: 1; visibility: visible; }

        .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .comparison-card {
            background: rgba(255,255,255,0.6); backdrop-filter: blur(10px);
            border: 1px solid #e9d5ff; border-radius: 16px; padding: 20px; transition: all .3s;
        }
        .comparison-card:hover { border-color: #a78bfa; box-shadow: 0 4px 15px rgba(139,92,246,0.08); }
        .comparison-card h5 { color: #7c3aed; margin-bottom: 8px; }
        .comparison-card p { margin: 0; font-size: 0.95em; color: #475569; }

        /* ‚îÄ‚îÄ Formula boxes ‚îÄ‚îÄ */
        .formula-box {
            background: linear-gradient(135deg, #fffbeb, #fef9c3);
            border: 2px solid #fcd34d; border-radius: 22px; padding: 30px; margin: 28px 0;
            position: relative; overflow: hidden;
        }
        .formula-box::before { content: 'üìê'; position: absolute; top: 12px; right: 15px; font-size: 1.5em; opacity: 0.25; }
        .formula-box h4 { color: #92400e; font-size: 1.2em; margin-bottom: 16px; display: flex; align-items: center; gap: 10px; }
        .formula-box p { color: #78350f; margin-bottom: 12px; font-size: 1.02em; }
        .formula {
            background: white; border: 2px solid #fcd34d; border-radius: 16px;
            padding: 20px 28px; margin: 18px 0; text-align: center;
            font-size: 1.3em; font-weight: 700; color: #1e293b; line-height: 1.8;
            box-shadow: 0 2px 10px rgba(0,0,0,0.04);
        }
        .formula .frac { display: inline-block; text-align: center; vertical-align: middle; }
        .formula .frac-num { display: block; border-bottom: 2px solid #1e293b; padding: 0 8px 4px; }
        .formula .frac-den { display: block; padding: 4px 8px 0; }
        .formula .highlight { color: #6d28d9; }
        .formula .blue { color: #1d4ed8; }
        .formula .orange { color: #c2410c; }
        .formula .green { color: #15803d; }
        .formula .small-note { font-size: 0.6em; color: #475569; font-weight: 500; display: block; margin-top: 6px; }
        .formula-label { display: inline-block; background: #fef08a; color: #92400e; font-size: 0.75em; font-weight: 700; padding: 3px 14px; border-radius: 20px; margin-bottom: 8px; }
        .layman-row {
            display: grid; grid-template-columns: auto 1fr; gap: 12px;
            align-items: flex-start; margin: 10px 0; padding: 12px 16px;
            background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid #fde68a;
        }
        .layman-row .var { font-weight: 800; color: #5b21b6; font-size: 1.1em; white-space: nowrap; min-width: 50px; }
        .layman-row .meaning { color: #44403c; font-size: 0.98em; }

        .worked-example {
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            border: 2px solid #86efac; border-radius: 18px; padding: 25px; margin: 18px 0;
        }
        .worked-example h5 { color: #166534; font-size: 1.08em; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .worked-example p { color: #14532d; margin-bottom: 8px; }
        .worked-example .calc {
            font-family: 'Fira Code', monospace; background: white;
            padding: 14px 18px; border-radius: 12px; margin: 10px 0;
            font-size: 0.92em; border-left: 4px solid #22c55e; color: #14532d; line-height: 1.9;
        }

        /* ‚îÄ‚îÄ Interactive playground ‚îÄ‚îÄ */
        .playground {
            background: rgba(255,255,255,0.55); backdrop-filter: blur(14px);
            border: 1px solid #bfdbfe; border-radius: 22px; padding: 30px; margin: 30px 0; text-align: center;
        }
        .playground h4 { color: #1e40af; margin-bottom: 10px; font-size: 1.15em; }
        .playground p { color: #334155; font-size: 0.95em; margin-bottom: 15px; }
        .playground svg { max-width: 100%; cursor: pointer; }
        .slider-row { display: flex; align-items: center; gap: 15px; justify-content: center; margin: 15px 0; flex-wrap: wrap; }
        .slider-row label { color: #1e3a5f; font-weight: 700; font-size: 0.92em; }
        .slider-row input[type="range"] {
            -webkit-appearance: none; appearance: none; width: 200px; height: 6px;
            background: #bfdbfe; border-radius: 3px; outline: none;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 22px; height: 22px;
            background: linear-gradient(135deg, #3b82f6, #2563eb); border-radius: 50%; cursor: pointer;
            box-shadow: 0 2px 8px rgba(37,99,235,0.35);
        }
        .slider-value { background: #dbeafe; color: #1e3a5f; padding: 4px 14px; border-radius: 8px; font-weight: 700; font-family: 'Fira Code', monospace; min-width: 60px; text-align: center; }

        /* ‚îÄ‚îÄ Click-to-reveal ‚îÄ‚îÄ */
        .reveal-btn {
            display: inline-flex; align-items: center; gap: 8px;
            background: #ede9fe;
            border: 1px solid #c4b5fd; color: #4c1d95;
            padding: 10px 22px; border-radius: 12px;
            cursor: pointer; font-family: 'Nunito'; font-weight: 700;
            font-size: 0.95em; transition: all .25s; margin: 10px 0;
        }
        .reveal-btn:hover { background: #ddd6fe; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(139,92,246,0.15); }
        .reveal-content { max-height: 0; overflow: hidden; transition: max-height 0.6s ease-out, opacity 0.4s; opacity: 0; }
        .reveal-content.open { max-height: 4000px; opacity: 1; }

        /* ‚îÄ‚îÄ Fade-in ‚îÄ‚îÄ */
        .fade-up { opacity: 0; transform: translateY(30px); transition: all 0.6s ease-out; }
        .fade-up.visible { opacity: 1; transform: translateY(0); }

        @media (max-width: 768px) {
            body { padding: 10px; font-size: 16px; }
            .header { padding: 30px 20px; } .header h1 { font-size: 1.8em; }
            .section { padding: 25px 18px; } .nav-buttons { flex-direction: column; }
            .comparison-grid { grid-template-columns: 1fr; }
            .slider-row input[type="range"] { width: 140px; }
        }
        html { scroll-behavior: smooth; }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="../index.html"><i class="fas fa-home"></i><span>Home</span></a>
            <a href="k-nearest-neighbors.html"><i class="fas fa-arrow-left"></i><span>Previous: kNN</span></a>
            <a href="index.html"><i class="fas fa-th-large"></i><span>Course Hub</span></a>
        </nav>

        <div class="header">
            <span class="beginner-badge">üë∂ ABSOLUTE BEGINNER FRIENDLY</span>
            <h1>üó°Ô∏è Support Vector Machines (SVM)</h1>
            <p>The algorithm that draws the BEST possible boundary between groups. Think of it as building the widest road between two neighborhoods!</p>
        </div>

        <!-- ======================================== -->
        <!-- Part 1: What is SVM?                     -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-question-circle"></i> Part 1: What is a Support Vector Machine?</h2>

            <p>A Support Vector Machine (SVM) is a <strong>supervised learning algorithm</strong> used for both <strong>classification</strong> and <strong>regression</strong>. Its superpower? It finds the <strong>best possible boundary</strong> (called a <strong>hyperplane</strong>) that separates different classes with the <strong>maximum margin</strong>.</p>

            <h3>üë∂ In One Sentence (Like You're 5)</h3>
            <p><strong>SVM</strong> means: "Draw a line between the red balls and blue balls, but make it as FAR from both groups as possible. That way, even if a new ball wobbles a little, it still ends up on the right side."</p>

            <div class="eli5-box">
                <h4>üè† Imagine This...</h4>
                <p>You have a big playground. On the left side, all the cats hang out. On the right side, all the dogs hang out. You need to build a fence between them.</p>
                <p>You COULD build it right next to the cats (but then a cat might jump over!). You COULD build it right next to the dogs (same problem!).</p>
                <p>The SMARTEST thing? Build the fence <strong>exactly in the middle</strong> so it's as far from BOTH groups as possible. That's what SVM does! It builds the fence (the <strong>hyperplane</strong>) with the <strong>widest possible gap</strong> (the <strong>margin</strong>) between both sides.</p>
                <p>The cats and dogs sitting closest to the fence? Those are the <strong>support vectors</strong>. They're the ones that determine where the fence goes!</p>
            </div>

            <div class="svm-visual">
                <h4>The SVM Concept - Maximum Margin Classifier</h4>
                <svg viewBox="0 0 500 350" xmlns="http://www.w3.org/2000/svg">
                    <!-- Margin area -->
                    <rect x="210" y="20" width="80" height="310" fill="#f3e8ff" stroke="none" opacity="0.6">
                        <animate attributeName="opacity" values="0.3;0.7;0.3" dur="3s" repeatCount="indefinite"/>
                    </rect>

                    <!-- Decision boundary (hyperplane) -->
                    <line x1="250" y1="15" x2="250" y2="335" stroke="#9333ea" stroke-width="3" stroke-dasharray="8,4">
                        <animate attributeName="stroke-opacity" values="0.6;1;0.6" dur="2s" repeatCount="indefinite"/>
                    </line>

                    <!-- Margin lines -->
                    <line x1="210" y1="15" x2="210" y2="335" stroke="#a855f7" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
                    <line x1="290" y1="15" x2="290" y2="335" stroke="#a855f7" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>

                    <!-- Margin arrow -->
                    <line x1="210" y1="340" x2="290" y2="340" stroke="#7e22ce" stroke-width="2"/>
                    <polygon points="210,340 216,336 216,344" fill="#7e22ce"/>
                    <polygon points="290,340 284,336 284,344" fill="#7e22ce"/>
                    <text x="250" y="355" text-anchor="middle" fill="#7e22ce" font-size="11" font-weight="700" font-family="Nunito">MARGIN (as wide as possible!)</text>

                    <!-- Class A points (blue circles - left side) -->
                    <circle cx="80" cy="60" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="120" cy="120" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="60" cy="180" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="140" cy="220" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="100" cy="280" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="50" cy="100" r="14" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="160" cy="160" r="14" fill="#3b82f6" opacity="0.8"/>

                    <!-- Support vectors (class A - closest to boundary) -->
                    <circle cx="210" cy="90" r="14" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3">
                        <animate attributeName="r" values="14;17;14" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="210" cy="250" r="14" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3">
                        <animate attributeName="r" values="14;17;14" dur="2s" begin="0.5s" repeatCount="indefinite"/>
                    </circle>

                    <!-- Class B points (orange circles - right side) -->
                    <circle cx="400" cy="50" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="370" cy="130" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="420" cy="200" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="380" cy="270" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="440" cy="300" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="450" cy="140" r="14" fill="#f97316" opacity="0.8"/>
                    <circle cx="350" cy="60" r="14" fill="#f97316" opacity="0.8"/>

                    <!-- Support vectors (class B) -->
                    <circle cx="290" cy="170" r="14" fill="#f97316" stroke="#c2410c" stroke-width="3">
                        <animate attributeName="r" values="14;17;14" dur="2s" begin="1s" repeatCount="indefinite"/>
                    </circle>

                    <!-- Labels -->
                    <text x="95" y="25" text-anchor="middle" fill="#1d4ed8" font-size="13" font-weight="800" font-family="Nunito">Class A (Blue)</text>
                    <text x="400" y="25" text-anchor="middle" fill="#c2410c" font-size="13" font-weight="800" font-family="Nunito">Class B (Orange)</text>
                    <text x="250" y="10" text-anchor="middle" fill="#9333ea" font-size="11" font-weight="700" font-family="Nunito">HYPERPLANE</text>

                    <!-- SV labels -->
                    <text x="210" y="78" text-anchor="middle" fill="#1e40af" font-size="8" font-weight="700" font-family="Nunito">Support Vector</text>
                    <text x="290" y="158" text-anchor="end" fill="#9a3412" font-size="8" font-weight="700" font-family="Nunito">Support Vector</text>
                </svg>
                <p style="color: #7e22ce; font-size: 0.95em; margin-top: 10px;">The pulsing dots are <strong>support vectors</strong> - the critical points that define the boundary. The shaded area is the <strong>margin</strong>.</p>
            </div>

            <h3>Why Is It Called "Support Vector Machine"?</h3>
            <ul style="margin-left: 22px; color: #334155; margin-bottom: 20px;">
                <li><strong>Support Vectors</strong> = the data points closest to the boundary (the ones that "support" or define where the boundary goes)</li>
                <li><strong>Vector</strong> = a fancy math word for "a point in space with coordinates"</li>
                <li><strong>Machine</strong> = it's a learning machine (algorithm)</li>
            </ul>

            <div class="key-point">
                <h4>üí° The Key Insight</h4>
                <ul>
                    <li>Out of potentially millions of data points, only a <strong>handful</strong> (the support vectors) actually matter for defining the boundary</li>
                    <li>Moving or removing any non-support-vector point does NOT change the boundary at all</li>
                    <li>This makes SVM <strong>memory efficient</strong> and robust to outliers far from the boundary</li>
                </ul>
            </div>
        </div>

        <!-- Interactive: Try Different Boundaries -->
        <div class="playground fade-up">
            <h4>üéÆ Interactive: Click to See Why Maximum Margin Wins!</h4>
            <p>Below are 3 possible boundaries for the SAME data. Click each button to see why SVM picks the widest margin.</p>
            <svg id="whyMarginSvg" viewBox="0 0 520 300" xmlns="http://www.w3.org/2000/svg" style="background:white;border-radius:16px;border:1px solid #e9d5ff;">
                <circle cx="90" cy="60" r="12" fill="#60a5fa"/><circle cx="60" cy="130" r="12" fill="#60a5fa"/>
                <circle cx="120" cy="170" r="12" fill="#60a5fa"/><circle cx="80" cy="220" r="12" fill="#60a5fa"/>
                <circle cx="140" cy="100" r="12" fill="#60a5fa"/><circle cx="50" cy="180" r="12" fill="#60a5fa"/>
                <circle cx="160" cy="200" r="12" fill="#60a5fa" stroke="#3b82f6" stroke-width="2.5" id="sv1"/>
                <circle cx="170" cy="130" r="12" fill="#60a5fa" stroke="#3b82f6" stroke-width="2.5" id="sv2"/>
                <circle cx="400" cy="70" r="12" fill="#fb923c"/><circle cx="430" cy="150" r="12" fill="#fb923c"/>
                <circle cx="370" cy="210" r="12" fill="#fb923c"/><circle cx="450" cy="230" r="12" fill="#fb923c"/>
                <circle cx="410" cy="110" r="12" fill="#fb923c"/><circle cx="460" cy="180" r="12" fill="#fb923c"/>
                <circle cx="350" cy="150" r="12" fill="#fb923c" stroke="#ea580c" stroke-width="2.5" id="sv3"/>
                <circle cx="340" cy="100" r="12" fill="#fb923c" stroke="#ea580c" stroke-width="2.5" id="sv4"/>
                <line id="tryLine" x1="260" y1="10" x2="260" y2="290" stroke="#a855f7" stroke-width="3" stroke-dasharray="8,4"/>
                <rect id="tryMargin" x="190" y="10" width="140" height="280" fill="#a855f7" opacity="0.08" rx="4"/>
                <text id="tryLabel" x="260" y="295" text-anchor="middle" fill="#6d28d9" font-size="12" font-weight="700" font-family="Nunito">Best boundary! Widest margin ‚úÖ</text>
            </svg>
            <div style="display:flex;gap:10px;justify-content:center;margin-top:15px;flex-wrap:wrap;">
                <button onclick="showBoundary('bad1')" style="background:#fee2e2;color:#b91c1c;border:1px solid #fca5a5;padding:10px 20px;border-radius:12px;cursor:pointer;font-family:Nunito;font-weight:700;">‚ùå Too close to Blue</button>
                <button onclick="showBoundary('best')" style="background:#ede9fe;color:#6d28d9;border:1px solid #c4b5fd;padding:10px 20px;border-radius:12px;cursor:pointer;font-family:Nunito;font-weight:700;">‚úÖ Maximum Margin (SVM)</button>
                <button onclick="showBoundary('bad2')" style="background:#fee2e2;color:#b91c1c;border:1px solid #fca5a5;padding:10px 20px;border-radius:12px;cursor:pointer;font-family:Nunito;font-weight:700;">‚ùå Too close to Orange</button>
            </div>
        </div>

        <!-- Interactive: C Parameter Slider -->
        <div class="playground fade-up">
            <h4>üéõÔ∏è Interactive: Drag the C Slider to See What Happens!</h4>
            <p>Move the slider and watch how the margin and boundary change in real-time.</p>
            <svg id="cSliderSvg" viewBox="0 0 520 280" xmlns="http://www.w3.org/2000/svg" style="background:white;border-radius:16px;border:1px solid #bfdbfe;">
                <circle cx="80" cy="60" r="11" fill="#60a5fa"/><circle cx="50" cy="120" r="11" fill="#60a5fa"/>
                <circle cx="110" cy="150" r="11" fill="#60a5fa"/><circle cx="70" cy="200" r="11" fill="#60a5fa"/>
                <circle cx="130" cy="90" r="11" fill="#60a5fa"/><circle cx="40" cy="170" r="11" fill="#60a5fa"/>
                <circle cx="155" cy="185" r="11" fill="#60a5fa" stroke="#3b82f6" stroke-width="2.5"/>
                <circle cx="165" cy="120" r="11" fill="#60a5fa" stroke="#3b82f6" stroke-width="2.5"/>
                <circle cx="220" cy="140" r="11" fill="#60a5fa" id="cOutlier" opacity="0.7"/>
                <circle cx="400" cy="50" r="11" fill="#fb923c"/><circle cx="430" cy="130" r="11" fill="#fb923c"/>
                <circle cx="370" cy="190" r="11" fill="#fb923c"/><circle cx="450" cy="210" r="11" fill="#fb923c"/>
                <circle cx="410" cy="100" r="11" fill="#fb923c"/><circle cx="460" cy="160" r="11" fill="#fb923c"/>
                <circle cx="345" cy="135" r="11" fill="#fb923c" stroke="#ea580c" stroke-width="2.5"/>
                <rect id="cMargin" x="190" y="5" width="140" height="270" fill="#a855f7" opacity="0.08" rx="4"/>
                <line id="cLine" x1="260" y1="5" x2="260" y2="275" stroke="#a855f7" stroke-width="3" stroke-dasharray="8,4"/>
                <text id="cText" x="260" y="275" text-anchor="middle" fill="#6d28d9" font-size="11" font-weight="700" font-family="Nunito">C = 1.0 ‚Äî Balanced margin</text>
            </svg>
            <div class="slider-row">
                <label>Small C (wide road, chill)</label>
                <input type="range" id="cSlider" min="1" max="100" value="50" oninput="updateCSlider(this.value)">
                <label>Big C (narrow road, strict)</label>
                <span class="slider-value" id="cVal">C = 1.0</span>
            </div>
            <p style="font-size:0.88em;color:#475569;margin-top:8px;">Notice: with small C the blue outlier is tolerated. With big C the boundary bends to avoid any errors!</p>
        </div>

        <!-- ======================================== -->
        <!-- Part 2: How SVM Works (The Math Made Easy) -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-cogs"></i> Part 2: How SVM Works (The Math Made Simple)</h2>

            <p>Don't worry - we'll make this painless! SVM is trying to solve one problem: <strong>"What's the best line (or surface) that separates the two classes?"</strong></p>

            <h3>The Hyperplane</h3>
            <p>A <strong>hyperplane</strong> is just a fancy word for a boundary:</p>
            <ul style="margin-left: 22px; color: #334155; margin-bottom: 20px;">
                <li>In <strong>2D</strong> (two features): the hyperplane is a <strong>line</strong></li>
                <li>In <strong>3D</strong> (three features): the hyperplane is a <strong>flat surface</strong> (like a sheet of paper)</li>
                <li>In <strong>100D</strong> (100 features): it's a 99-dimensional surface (can't visualize, but the math works the same!)</li>
            </ul>

            <div class="analogy-box">
                <h4>üçï Pizza Analogy</h4>
                <p>Imagine a pizza with toppings on one half (pepperoni) and different toppings on the other (mushrooms). The hyperplane is the cut that perfectly divides the pizza in half. SVM finds the cut that keeps the widest "crust border" between pepperoni territory and mushroom territory.</p>
            </div>

            <h3>The Margin</h3>
            <p>The <strong>margin</strong> is the distance between the hyperplane and the nearest data point from either class. SVM wants to <strong>maximize this margin</strong>. A wider margin means better generalization to new, unseen data.</p>

            <div class="eli5-box">
                <h4>üõ£Ô∏è The Highway Analogy</h4>
                <p>Think of the hyperplane as a <strong>highway</strong> between two cities (two classes). The support vectors are the buildings closest to the highway on each side. SVM builds the <strong>widest possible highway</strong> so there's maximum clearance from the buildings on both sides. A wider highway means even if a new building is slightly off, it still clearly belongs to its city!</p>
            </div>

            <h3>The Math (Don't Panic - We'll Go Slow!)</h3>

            <!-- Whiteboard-style diagram like the user's sketch -->
            <div class="svm-visual fade-up">
                <h4>The Whiteboard View: Two Classes, Many Lines, One Best Answer</h4>
                <svg viewBox="0 0 600 350" xmlns="http://www.w3.org/2000/svg">
                    <rect width="600" height="350" rx="12" fill="#faf5ff"/>
                    <!-- Background grid -->
                    <defs>
                        <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(139,92,246,0.06)" stroke-width="1"/></pattern>
                    </defs>
                    <rect width="600" height="350" fill="url(#grid)" rx="12"/>

                    <!-- Class blobs -->
                    <ellipse cx="150" cy="175" rx="100" ry="120" fill="rgba(59,130,246,0.06)" stroke="rgba(59,130,246,0.2)" stroke-width="2" stroke-dasharray="6,4"/>
                    <ellipse cx="450" cy="175" rx="100" ry="120" fill="rgba(249,115,22,0.06)" stroke="rgba(249,115,22,0.2)" stroke-width="2" stroke-dasharray="6,4"/>

                    <!-- Points in class A (blue) -->
                    <circle cx="100" cy="100" r="10" fill="#60a5fa"/><circle cx="130" cy="160" r="10" fill="#60a5fa"/>
                    <circle cx="160" cy="220" r="10" fill="#60a5fa"/><circle cx="110" cy="250" r="10" fill="#60a5fa"/>
                    <circle cx="180" cy="130" r="10" fill="#60a5fa"/><circle cx="90" cy="190" r="10" fill="#60a5fa"/>
                    <circle cx="200" cy="180" r="10" fill="#60a5fa" stroke="#3b82f6" stroke-width="3">
                        <animate attributeName="r" values="10;13;10" dur="2s" repeatCount="indefinite"/>
                    </circle>

                    <!-- Points in class B (orange) -->
                    <circle cx="410" cy="90" r="10" fill="#fb923c"/><circle cx="470" cy="150" r="10" fill="#fb923c"/>
                    <circle cx="440" cy="220" r="10" fill="#fb923c"/><circle cx="490" cy="110" r="10" fill="#fb923c"/>
                    <circle cx="420" cy="260" r="10" fill="#fb923c"/><circle cx="500" cy="200" r="10" fill="#fb923c"/>
                    <circle cx="390" cy="170" r="10" fill="#fb923c" stroke="#ea580c" stroke-width="3">
                        <animate attributeName="r" values="10;13;10" dur="2s" begin="1s" repeatCount="indefinite"/>
                    </circle>

                    <!-- Many possible lines (bad ones) -->
                    <line x1="230" y1="30" x2="350" y2="320" stroke="rgba(239,68,68,0.25)" stroke-width="1.5"/>
                    <line x1="250" y1="10" x2="280" y2="340" stroke="rgba(239,68,68,0.25)" stroke-width="1.5"/>
                    <line x1="320" y1="20" x2="270" y2="330" stroke="rgba(239,68,68,0.25)" stroke-width="1.5"/>

                    <!-- Arrow from bad lines to best line -->
                    <path d="M300,175 L295,175" stroke="rgba(255,255,255,0.3)" stroke-width="1" marker-end="none"/>

                    <!-- THE BEST LINE (SVM's choice) -->
                    <line x1="295" y1="20" x2="295" y2="330" stroke="#a855f7" stroke-width="3">
                        <animate attributeName="stroke-opacity" values="0.7;1;0.7" dur="2s" repeatCount="indefinite"/>
                    </line>
                    <!-- Margin -->
                    <rect x="230" y="20" width="130" height="310" fill="#a855f7" opacity="0.06" rx="4"/>

                    <!-- Labels in bubble style -->
                    <rect x="8" y="15" width="85" height="35" rx="17" fill="#dbeafe" stroke="#93c5fd" stroke-width="1.5"/>
                    <text x="50" y="38" text-anchor="middle" fill="#1d4ed8" font-size="14" font-weight="800" font-family="Nunito">y = +1</text>

                    <rect x="505" y="15" width="85" height="35" rx="17" fill="#ffedd5" stroke="#fdba74" stroke-width="1.5"/>
                    <text x="548" y="38" text-anchor="middle" fill="#c2410c" font-size="14" font-weight="800" font-family="Nunito">y = -1</text>

                    <!-- Constraint bubbles (like the user's whiteboard) -->
                    <rect x="340" y="42" width="155" height="32" rx="16" fill="#ede9fe" stroke="#a78bfa" stroke-width="1.5"/>
                    <text x="418" y="63" text-anchor="middle" fill="#6d28d9" font-size="12" font-weight="700" font-family="Nunito">w¬∑x + b ‚â• +1</text>

                    <rect x="340" y="82" width="155" height="32" rx="16" fill="#ede9fe" stroke="#a78bfa" stroke-width="1.5"/>
                    <text x="418" y="103" text-anchor="middle" fill="#6d28d9" font-size="12" font-weight="700" font-family="Nunito">w¬∑x + b ‚â§ -1</text>

                    <rect x="325" y="126" width="185" height="32" rx="16" fill="#fef9c3" stroke="#fcd34d" stroke-width="1.5"/>
                    <text x="418" y="147" text-anchor="middle" fill="#92400e" font-size="12" font-weight="800" font-family="Nunito">y(w¬∑x + b) ‚â• 1</text>

                    <text x="295" y="346" text-anchor="middle" fill="#6b7280" font-size="10" font-family="Nunito">SVM picks the ONE line with the widest margin!</text>
                </svg>
            </div>

            <p>Now for the math behind each formula. <strong>Don't panic!</strong> Click each one to expand only when you're ready:</p>

            <!-- FORMULA 1: Dot Product -->
            <button class="reveal-btn" onclick="toggleReveal('rev-dot')"><i class="fas fa-chevron-down"></i> Formula 1: The Dot Product ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-dot">
            <div class="formula-box">
                <h4>üìê Formula 1: The Dot Product (the foundation of EVERYTHING)</h4>
                <p>Before we understand SVM's math, we need one building block: the <strong>dot product</strong>. It tells you how much two vectors "agree" in direction.</p>

                <span class="formula-label">THE FORMULA</span>
                <div class="formula">
                    <span class="blue">A</span> ¬∑ <span class="orange">B</span> = |<span class="blue">A</span>| √ó |<span class="orange">B</span>| √ó cos Œ∏
                </div>

                <div class="layman-row">
                    <span class="var">A ¬∑ B</span>
                    <span class="meaning">The dot product ‚Äî a single number that tells you how "aligned" A and B are</span>
                </div>
                <div class="layman-row">
                    <span class="var">|A|</span>
                    <span class="meaning">The length (magnitude) of vector A ‚Äî how "long" the arrow is</span>
                </div>
                <div class="layman-row">
                    <span class="var">|B|</span>
                    <span class="meaning">The length (magnitude) of vector B</span>
                </div>
                <div class="layman-row">
                    <span class="var">cos Œ∏</span>
                    <span class="meaning">The cosine of the angle between A and B (1 = same direction, 0 = perpendicular, -1 = opposite)</span>
                </div>

                <p>Rearranging, we can find the angle between any two vectors:</p>
                <div class="formula">
                    cos Œ∏ = <span class="frac"><span class="frac-num"><span class="blue">A</span> ¬∑ <span class="orange">B</span></span><span class="frac-den">|<span class="blue">A</span>| √ó |<span class="orange">B</span>|</span></span>
                </div>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: Grocery Shopping Vectors</h5>
                    <p>Two shoppers buy items. Shopper A buys: 3 apples, 1 banana. Shopper B buys: 2 apples, 4 bananas.</p>
                    <p>Their shopping vectors are: <strong>A = (3, 1)</strong> and <strong>B = (2, 4)</strong></p>
                    <div class="calc">
                        A ¬∑ B = (3 √ó 2) + (1 √ó 4) = 6 + 4 = <strong>10</strong><br>
                        |A| = ‚àö(3¬≤ + 1¬≤) = ‚àö(9 + 1) = ‚àö10 ‚âà <strong>3.16</strong><br>
                        |B| = ‚àö(2¬≤ + 4¬≤) = ‚àö(4 + 16) = ‚àö20 ‚âà <strong>4.47</strong><br>
                        cos Œ∏ = 10 / (3.16 √ó 4.47) = 10 / 14.14 ‚âà <strong>0.707</strong><br>
                        Œ∏ = arccos(0.707) ‚âà <strong>45¬∞</strong>
                    </div>
                    <p>Their shopping patterns are at a 45¬∞ angle ‚Äî somewhat similar but not identical! If cos Œ∏ = 1, they'd buy the exact same ratio of items.</p>
                </div>
            </div>

            </div><!-- close reveal-content for dot product -->

            <button class="reveal-btn" onclick="toggleReveal('rev-hyp')"><i class="fas fa-chevron-down"></i> Formula 2: The Hyperplane Equation ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-hyp">
            <div class="formula-box">
                <h4>üìê Formula 2: The Hyperplane Equation</h4>
                <p>The hyperplane is the boundary that SVM draws. In math, it's:</p>

                <span class="formula-label">THE FORMULA</span>
                <div class="formula">
                    <span class="highlight">w</span> ¬∑ <span class="blue">x</span> + <span class="orange">b</span> = 0
                    <span class="small-note">This defines all points ON the boundary line</span>
                </div>

                <div class="layman-row">
                    <span class="var">w</span>
                    <span class="meaning"><strong>Weight vector</strong> ‚Äî determines the DIRECTION / tilt of the boundary. Think of it as which way the fence faces.</span>
                </div>
                <div class="layman-row">
                    <span class="var">x</span>
                    <span class="meaning"><strong>Data point</strong> ‚Äî a specific point in your dataset (e.g., a customer with features: age=25, income=50K)</span>
                </div>
                <div class="layman-row">
                    <span class="var">b</span>
                    <span class="meaning"><strong>Bias</strong> ‚Äî shifts the boundary left/right (or up/down). Like sliding the fence sideways without changing its angle.</span>
                </div>

                <p>For <strong>classification</strong>, we check which side a new point falls on:</p>
                <div class="formula">
                    If <span class="highlight">w</span> ¬∑ <span class="blue">x</span> + <span class="orange">b</span> &gt; 0 ‚Üí <span class="green">Class +1</span> (one side)<br>
                    If <span class="highlight">w</span> ¬∑ <span class="blue">x</span> + <span class="orange">b</span> &lt; 0 ‚Üí <span style="color:#dc2626;">Class -1</span> (other side)
                </div>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: Classifying Fruits</h5>
                    <p>We want to classify fruits as Apples (+1) or Oranges (-1) using two features: weight (x‚ÇÅ) and color_redness (x‚ÇÇ).</p>
                    <p>Say SVM found: <strong>w = (0.6, 0.8)</strong> and <strong>b = -5</strong></p>
                    <p>New fruit has weight = 7, redness = 3:</p>
                    <div class="calc">
                        w ¬∑ x + b = (0.6 √ó 7) + (0.8 √ó 3) + (-5)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4.2 + 2.4 - 5<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <strong>1.6</strong> &gt; 0 ‚Üí It's an <strong>Apple! ‚úÖ</strong>
                    </div>
                    <p>Another fruit: weight = 4, redness = 2:</p>
                    <div class="calc">
                        w ¬∑ x + b = (0.6 √ó 4) + (0.8 √ó 2) + (-5)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2.4 + 1.6 - 5<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <strong>-1.0</strong> &lt; 0 ‚Üí It's an <strong>Orange! üçä</strong>
                    </div>
                </div>
            </div>

            </div><!-- close reveal-content for hyperplane -->

            <button class="reveal-btn" onclick="toggleReveal('rev-margin')"><i class="fas fa-chevron-down"></i> Formula 3: Margin Width ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-margin">
            <div class="formula-box">
                <h4>üìê Formula 3: The Margin Width</h4>
                <p>The margin is the gap between the two classes. SVM wants to <strong>maximize</strong> this. Here's how it's calculated:</p>

                <p>The support vectors on the positive side satisfy <strong>w ¬∑ x‚Å∫ + b = +1</strong>, and on the negative side: <strong>w ¬∑ x‚Åª + b = -1</strong>.</p>

                <p>Using the dot product and cosine, the margin width is:</p>

                <span class="formula-label">MARGIN WIDTH</span>
                <div class="formula">
                    cos Œ∏ = <span class="frac"><span class="frac-num"><span class="highlight">w</span> ¬∑ (<span class="blue">x‚Å∫</span> - <span style="color:#dc2626;">x‚Åª</span>)</span><span class="frac-den">|<span class="highlight">w</span>| √ó |<span class="blue">x‚Å∫</span> - <span style="color:#dc2626;">x‚Åª</span>|</span></span>
                </div>

                <p>The actual distance (width of the margin road) projected onto the weight vector's direction simplifies beautifully to:</p>

                <div class="formula">
                    Margin = <span class="frac"><span class="frac-num"><span class="green">2</span></span><span class="frac-den">|<span class="highlight">w</span>|</span></span>
                    <span class="small-note">The margin width is simply 2 divided by the length of the weight vector!</span>
                </div>

                <div class="layman-row">
                    <span class="var">|w|</span>
                    <span class="meaning">The length of the weight vector: |w| = ‚àö(w‚ÇÅ¬≤ + w‚ÇÇ¬≤ + ... + w‚Çô¬≤)</span>
                </div>
                <div class="layman-row">
                    <span class="var">2/|w|</span>
                    <span class="meaning">The total width of the "road" between the two classes. Bigger = better!</span>
                </div>

                <p><strong>So maximizing the margin = minimizing |w|!</strong> That's why SVM's optimization objective is to find the smallest possible |w|.</p>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: How Wide is the Road?</h5>
                    <p>Say SVM found weights <strong>w = (3, 4)</strong>.</p>
                    <div class="calc">
                        |w| = ‚àö(3¬≤ + 4¬≤) = ‚àö(9 + 16) = ‚àö25 = <strong>5</strong><br>
                        Margin = 2 / |w| = 2 / 5 = <strong>0.4</strong>
                    </div>
                    <p>Now say another SVM found weights <strong>w = (0.6, 0.8)</strong>.</p>
                    <div class="calc">
                        |w| = ‚àö(0.6¬≤ + 0.8¬≤) = ‚àö(0.36 + 0.64) = ‚àö1 = <strong>1</strong><br>
                        Margin = 2 / |w| = 2 / 1 = <strong>2.0</strong>
                    </div>
                    <p>The second SVM has a margin of 2.0 vs 0.4 ‚Äî <strong>5x wider road!</strong> SVM would prefer the second one because wider margin = better generalization.</p>
                </div>
            </div>

            </div><!-- close reveal-content for margin -->

            <button class="reveal-btn" onclick="toggleReveal('rev-opt')"><i class="fas fa-chevron-down"></i> Formula 4: The Optimization Objective ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-opt">
            <div class="formula-box">
                <h4>üìê Formula 4: The SVM Optimization Objective</h4>
                <p>Putting it all together, SVM solves this optimization problem:</p>

                <span class="formula-label">HARD MARGIN (perfect separation)</span>
                <div class="formula">
                    Minimize: <span class="frac"><span class="frac-num">1</span><span class="frac-den">2</span></span> |<span class="highlight">w</span>|¬≤
                    <span class="small-note">Subject to: y·µ¢ (w ¬∑ x·µ¢ + b) ‚â• 1 for ALL data points</span>
                </div>

                <div class="layman-row">
                    <span class="var">¬Ω|w|¬≤</span>
                    <span class="meaning">We minimize the squared length of w (which maximizes the margin). The ¬Ω is just for cleaner math when taking derivatives.</span>
                </div>
                <div class="layman-row">
                    <span class="var">y·µ¢</span>
                    <span class="meaning">The true label of point i: either +1 or -1</span>
                </div>
                <div class="layman-row">
                    <span class="var">y·µ¢(w¬∑x·µ¢+b) ‚â• 1</span>
                    <span class="meaning">Every point must be on the CORRECT side of the boundary AND at least as far as the margin line. If the class is +1, then w¬∑x+b must be ‚â• +1. If class is -1, then w¬∑x+b must be ‚â§ -1.</span>
                </div>

                <div class="analogy-box" style="border-color: #eab308;">
                    <h4>üèóÔ∏è Building a Highway (Layman Version)</h4>
                    <p>The city wants to build a highway. The rules: (1) Make the highway as <strong>wide</strong> as possible (minimize |w|). (2) <strong>No building</strong> can be inside the highway lanes (all y·µ¢(w¬∑x·µ¢+b) ‚â• 1). The city planner (SVM algorithm) finds the widest road that doesn't demolish any building.</p>
                </div>
            </div>

            </div><!-- close reveal-content for optimization -->

            <p>SVM finds the values of <strong>w</strong> and <strong>b</strong> that maximize the margin while correctly classifying all training points (or allowing some slack for noisy data).</p>

            <h3>Step-by-Step: How SVM Finds the Best Boundary</h3>
            <div class="step-card">
                <div class="step-num">1</div>
                <div><h5>Start with labeled data</h5><p>Each data point has features (X) and a class label (+1 or -1).</p></div>
            </div>
            <div class="step-card">
                <div class="step-num">2</div>
                <div><h5>Find all possible separating hyperplanes</h5><p>There are infinitely many lines that could separate the classes. SVM tests them all (mathematically, via optimization).</p></div>
            </div>
            <div class="step-card">
                <div class="step-num">3</div>
                <div><h5>Pick the one with the MAXIMUM margin</h5><p>The hyperplane with the widest gap to the nearest points on both sides wins. This is found by solving a convex optimization problem (quadratic programming).</p></div>
            </div>
            <div class="step-card">
                <div class="step-num">4</div>
                <div><h5>Identify the support vectors</h5><p>The points that sit exactly on the margin boundary are the support vectors. Only these points influence the final model.</p></div>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 3: Hard Margin vs Soft Margin       -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-balance-scale"></i> Part 3: Hard Margin vs. Soft Margin (The C Parameter)</h2>

            <p>What happens when the data ISN'T perfectly separable? Like when one cat accidentally wandered into the dog side of the playground?</p>

            <h3>Hard Margin SVM</h3>
            <p><strong>Hard margin</strong> means: "I demand PERFECT separation. Not a single point can be on the wrong side!" This only works when data is perfectly linearly separable (rare in real life!).</p>

            <!-- VISUAL: Hard Margin -->
            <div class="svm-visual fade-up">
                <h4>Hard Margin: Perfect Separation Required!</h4>
                <svg viewBox="0 0 550 300" xmlns="http://www.w3.org/2000/svg">
                    <rect width="550" height="300" rx="12" fill="#faf5ff"/>
                    <text x="275" y="22" text-anchor="middle" fill="#7c3aed" font-size="12" font-weight="700" font-family="Nunito">Every single point MUST be on the correct side</text>
                    <!-- Margin area -->
                    <rect x="230" y="30" width="90" height="240" fill="#ede9fe" rx="4"/>
                    <line x1="275" y1="30" x2="275" y2="270" stroke="#7c3aed" stroke-width="2.5" stroke-dasharray="6,4"/>
                    <line x1="230" y1="30" x2="230" y2="270" stroke="#a78bfa" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
                    <line x1="320" y1="30" x2="320" y2="270" stroke="#a78bfa" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
                    <!-- Blue class -->
                    <circle cx="90" cy="70" r="13" fill="#3b82f6"/><circle cx="60" cy="140" r="13" fill="#3b82f6"/>
                    <circle cx="120" cy="190" r="13" fill="#3b82f6"/><circle cx="80" cy="230" r="13" fill="#3b82f6"/>
                    <circle cx="150" cy="110" r="13" fill="#3b82f6"/><circle cx="50" cy="180" r="13" fill="#3b82f6"/>
                    <circle cx="170" cy="160" r="13" fill="#3b82f6"/>
                    <!-- Support vectors blue -->
                    <circle cx="230" cy="100" r="13" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3"/>
                    <circle cx="230" cy="210" r="13" fill="#3b82f6" stroke="#1d4ed8" stroke-width="3"/>
                    <!-- Orange class -->
                    <circle cx="440" cy="60" r="13" fill="#f97316"/><circle cx="410" cy="140" r="13" fill="#f97316"/>
                    <circle cx="470" cy="200" r="13" fill="#f97316"/><circle cx="490" cy="110" r="13" fill="#f97316"/>
                    <circle cx="420" cy="240" r="13" fill="#f97316"/><circle cx="380" cy="80" r="13" fill="#f97316"/>
                    <!-- Support vectors orange -->
                    <circle cx="320" cy="155" r="13" fill="#f97316" stroke="#c2410c" stroke-width="3"/>
                    <!-- Labels -->
                    <text x="100" y="280" text-anchor="middle" fill="#1d4ed8" font-size="12" font-weight="700" font-family="Nunito">Blue (y=+1)</text>
                    <text x="440" y="280" text-anchor="middle" fill="#c2410c" font-size="12" font-weight="700" font-family="Nunito">Orange (y=-1)</text>
                    <text x="275" y="290" text-anchor="middle" fill="#16a34a" font-size="11" font-weight="800" font-family="Nunito">‚úÖ Works! All points perfectly separated</text>
                </svg>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è But What If One Point Is on the Wrong Side?</h4>
                <p>Hard margin BREAKS if even one point is in the "wrong" zone. Real data is messy. That's why we almost NEVER use hard margin in practice.</p>
            </div>

            <!-- VISUAL: Hard Margin BREAKS -->
            <div class="svm-visual fade-up">
                <h4>Hard Margin FAILS: One Outlier Ruins Everything!</h4>
                <svg viewBox="0 0 550 300" xmlns="http://www.w3.org/2000/svg">
                    <rect width="550" height="300" rx="12" fill="#fef2f2"/>
                    <!-- Blue points -->
                    <circle cx="90" cy="70" r="13" fill="#3b82f6"/><circle cx="60" cy="140" r="13" fill="#3b82f6"/>
                    <circle cx="120" cy="190" r="13" fill="#3b82f6"/><circle cx="80" cy="230" r="13" fill="#3b82f6"/>
                    <circle cx="150" cy="110" r="13" fill="#3b82f6"/><circle cx="50" cy="180" r="13" fill="#3b82f6"/>
                    <!-- THE OUTLIER - a blue point that wandered into orange territory! -->
                    <circle cx="380" cy="150" r="15" fill="#3b82f6" stroke="#ef4444" stroke-width="4" stroke-dasharray="4,3">
                        <animate attributeName="r" values="15;19;15" dur="1.5s" repeatCount="indefinite"/>
                    </circle>
                    <text x="380" y="130" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="800" font-family="Nunito">OUTLIER!</text>
                    <!-- Orange points -->
                    <circle cx="440" cy="60" r="13" fill="#f97316"/><circle cx="410" cy="140" r="13" fill="#f97316"/>
                    <circle cx="470" cy="200" r="13" fill="#f97316"/><circle cx="490" cy="110" r="13" fill="#f97316"/>
                    <circle cx="420" cy="240" r="13" fill="#f97316"/>
                    <!-- Terrible narrow boundary that hard margin creates -->
                    <rect x="390" y="30" width="20" height="240" fill="#fee2e2" rx="3"/>
                    <line x1="400" y1="30" x2="400" y2="270" stroke="#ef4444" stroke-width="2.5" stroke-dasharray="6,4"/>
                    <!-- X marks -->
                    <text x="275" y="25" text-anchor="middle" fill="#b91c1c" font-size="13" font-weight="800" font-family="Nunito">‚ùå Hard Margin creates a TERRIBLE boundary</text>
                    <text x="275" y="290" text-anchor="middle" fill="#b91c1c" font-size="11" font-weight="700" font-family="Nunito">The boundary moved way right to avoid the outlier ‚Üí tiny margin, bad model!</text>
                </svg>
            </div>

            <h3>Soft Margin SVM (The Practical One)</h3>
            <p><strong>Soft margin</strong> means: "I'll try to separate perfectly, but I'll <em>tolerate some misclassifications</em> if it gives me a wider, more robust margin." Each misclassified or margin-violating point gets a <strong>penalty</strong>.</p>

            <!-- VISUAL: Soft Margin -->
            <div class="svm-visual fade-up">
                <h4>Soft Margin: Tolerates the Outlier, Keeps a Wide Margin! ‚úÖ</h4>
                <svg viewBox="0 0 550 300" xmlns="http://www.w3.org/2000/svg">
                    <rect width="550" height="300" rx="12" fill="#f0fdf4"/>
                    <!-- Margin area - WIDE -->
                    <rect x="220" y="30" width="110" height="240" fill="#dcfce7" rx="4"/>
                    <line x1="275" y1="30" x2="275" y2="270" stroke="#16a34a" stroke-width="2.5" stroke-dasharray="6,4"/>
                    <line x1="220" y1="30" x2="220" y2="270" stroke="#4ade80" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
                    <line x1="330" y1="30" x2="330" y2="270" stroke="#4ade80" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
                    <!-- Blue points -->
                    <circle cx="90" cy="70" r="13" fill="#3b82f6"/><circle cx="60" cy="140" r="13" fill="#3b82f6"/>
                    <circle cx="120" cy="190" r="13" fill="#3b82f6"/><circle cx="80" cy="230" r="13" fill="#3b82f6"/>
                    <circle cx="150" cy="110" r="13" fill="#3b82f6"/><circle cx="50" cy="180" r="13" fill="#3b82f6"/>
                    <!-- The outlier - NOW it's OK, just gets a small penalty -->
                    <circle cx="380" cy="150" r="15" fill="#3b82f6" stroke="#f59e0b" stroke-width="3"/>
                    <text x="380" y="130" text-anchor="middle" fill="#92400e" font-size="9" font-weight="700" font-family="Nunito">Penalty: Œæ=1.2</text>
                    <!-- Orange points -->
                    <circle cx="440" cy="60" r="13" fill="#f97316"/><circle cx="410" cy="140" r="13" fill="#f97316"/>
                    <circle cx="470" cy="200" r="13" fill="#f97316"/><circle cx="490" cy="110" r="13" fill="#f97316"/>
                    <circle cx="420" cy="240" r="13" fill="#f97316"/>
                    <!-- Labels -->
                    <text x="275" y="22" text-anchor="middle" fill="#16a34a" font-size="13" font-weight="800" font-family="Nunito">‚úÖ Soft Margin ignores the outlier, keeps WIDE margin</text>
                    <text x="275" y="290" text-anchor="middle" fill="#16a34a" font-size="11" font-weight="700" font-family="Nunito">The outlier gets a slack penalty (Œæ), but the boundary stays sensible!</text>
                </svg>
            </div>

            <div class="analogy-box">
                <h4>üè´ The Classroom Analogy</h4>
                <p><strong>Hard margin teacher:</strong> "If even ONE student is sitting on the wrong side of the classroom, I REFUSE to draw the dividing line!" (Impractical - what if a student fell?)</p>
                <p><strong>Soft margin teacher:</strong> "I'll draw the best line I can. If 2 students are slightly on the wrong side, I'll allow it as long as the overall separation is good. Those 2 get a small penalty (detention!), but the line still works great for the other 98 students."</p>
            </div>

            <h3>The C Parameter (Regularization Strength)</h3>
            <p>The <strong>C parameter</strong> controls how much we penalize misclassifications:</p>

            <table class="data-table">
                <thead>
                    <tr><th>C Value</th><th>What Happens</th><th>Analogy</th><th>Risk</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong style="color:#9333ea;">Large C</strong> (e.g., 1000)</td>
                        <td>Heavy penalty for errors. Tries very hard to classify every point correctly. Narrow margin.</td>
                        <td>Strict teacher: "Zero tolerance for mistakes!"</td>
                        <td>Overfitting</td>
                    </tr>
                    <tr>
                        <td><strong style="color:#9333ea;">Small C</strong> (e.g., 0.01)</td>
                        <td>Light penalty for errors. Allows more misclassifications. Wider margin.</td>
                        <td>Chill teacher: "A few mistakes are fine, as long as the big picture works."</td>
                        <td>Underfitting</td>
                    </tr>
                    <tr>
                        <td><strong style="color:#9333ea;">C = 1</strong> (default)</td>
                        <td>Balanced. Usually a good starting point.</td>
                        <td>Reasonable teacher: fair but firm.</td>
                        <td>Good default</td>
                    </tr>
                </tbody>
            </table>

            <button class="reveal-btn" onclick="toggleReveal('rev-soft')"><i class="fas fa-chevron-down"></i> Formula 5: Soft Margin Math ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-soft">
            <div class="formula-box">
                <h4>üìê Formula 5: The Soft Margin Objective (with C)</h4>
                <p>When data isn't perfectly separable, we add <strong>slack variables</strong> (Œæ) that allow some points to violate the margin:</p>

                <span class="formula-label">SOFT MARGIN</span>
                <div class="formula">
                    Minimize: <span class="frac"><span class="frac-num">1</span><span class="frac-den">2</span></span> |<span class="highlight">w</span>|¬≤ + <span class="orange">C</span> √ó Œ£ <span class="blue">Œæ·µ¢</span>
                    <span class="small-note">Subject to: y·µ¢(w ¬∑ x·µ¢ + b) ‚â• 1 - Œæ·µ¢, and Œæ·µ¢ ‚â• 0</span>
                </div>

                <div class="layman-row">
                    <span class="var">Œæ·µ¢ (xi)</span>
                    <span class="meaning"><strong>Slack variable</strong> ‚Äî how much point i is "allowed to cheat." If Œæ·µ¢ = 0, the point is correctly classified and outside the margin. If 0 &lt; Œæ·µ¢ &lt; 1, it's inside the margin but on the correct side. If Œæ·µ¢ &gt; 1, it's misclassified!</span>
                </div>
                <div class="layman-row">
                    <span class="var">C √ó Œ£Œæ·µ¢</span>
                    <span class="meaning"><strong>Total penalty</strong> ‚Äî C controls how harsh we are. Big C = expensive to cheat = narrow margin. Small C = cheap to cheat = wide margin.</span>
                </div>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: The Parking Ticket Analogy</h5>
                    <p>Think of C as the fine for parking in a no-parking zone (the margin).</p>
                    <div class="calc">
                        C = 1000 (Dubai parking fine!) ‚Üí Drivers are terrified.<br>
                        &nbsp;&nbsp; No one parks there. Margin stays clear but very narrow.<br><br>
                        C = 0.01 (barely any fine) ‚Üí Drivers park wherever they want.<br>
                        &nbsp;&nbsp; The margin is wide but lots of "violations" (misclassifications).
                    </div>
                    <p>Say we have 3 points that violate: Œæ‚ÇÅ = 0.3, Œæ‚ÇÇ = 0.5, Œæ‚ÇÉ = 1.2</p>
                    <div class="calc">
                        With C = 100: Penalty = 100 √ó (0.3 + 0.5 + 1.2) = 100 √ó 2.0 = <strong>200</strong> (ouch!)<br>
                        With C = 0.1: Penalty = 0.1 √ó (0.3 + 0.5 + 1.2) = 0.1 √ó 2.0 = <strong>0.2</strong> (meh)
                    </div>
                    <p>With high C, those 3 violations are very costly, so SVM works harder to avoid them. With low C, SVM barely cares and focuses on a wider margin instead.</p>
                </div>
            </div>

            </div><!-- close reveal-content for soft margin -->

            <div class="key-point">
                <h4>üí° How to Choose C?</h4>
                <ul>
                    <li>Use <strong>cross-validation</strong> to try different C values (e.g., 0.001, 0.01, 0.1, 1, 10, 100, 1000)</li>
                    <li>Pick the C that gives the best validation accuracy</li>
                    <li>Scikit-learn makes this easy with <code>GridSearchCV</code></li>
                </ul>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 4: The Kernel Trick                 -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-magic"></i> Part 4: The Kernel Trick (SVM's Secret Weapon!)</h2>

            <p>What if the data <strong>can't be separated by a straight line at all</strong>? Like if the blue points form a circle surrounded by orange points? No straight line can separate them!</p>

            <div class="svm-visual">
                <h4>The Problem: Non-Linearly Separable Data</h4>
                <svg viewBox="0 0 500 250" xmlns="http://www.w3.org/2000/svg">
                    <!-- Inner circle points (blue) -->
                    <circle cx="250" cy="125" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="230" cy="100" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="270" cy="100" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="240" cy="145" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="260" cy="145" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="250" cy="90" r="12" fill="#3b82f6" opacity="0.8"/>
                    <circle cx="235" cy="125" r="12" fill="#3b82f6" opacity="0.8"/>

                    <!-- Outer ring points (orange) -->
                    <circle cx="150" cy="60" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="350" cy="60" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="100" cy="125" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="400" cy="125" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="150" cy="190" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="350" cy="190" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="200" cy="40" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="300" cy="40" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="200" cy="210" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="300" cy="210" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="130" cy="80" r="12" fill="#f97316" opacity="0.8"/>
                    <circle cx="370" cy="80" r="12" fill="#f97316" opacity="0.8"/>

                    <text x="250" y="240" text-anchor="middle" fill="#991b1b" font-size="12" font-weight="700" font-family="Nunito">No straight line can separate these! We need the kernel trick.</text>
                </svg>
            </div>

            <!-- VISUAL: Kernel Trick - 2D to 3D -->
            <div class="svm-visual fade-up">
                <h4>The Kernel Trick: Lift Data to a Higher Dimension!</h4>
                <svg viewBox="0 0 620 280" xmlns="http://www.w3.org/2000/svg">
                    <rect width="620" height="280" rx="12" fill="#f5f3ff"/>
                    <!-- LEFT: 2D view (can't separate) -->
                    <rect x="10" y="30" width="240" height="220" rx="12" fill="white" stroke="#e9d5ff" stroke-width="2"/>
                    <text x="130" y="25" text-anchor="middle" fill="#7c3aed" font-size="13" font-weight="800" font-family="Nunito">2D: Can't Separate! ‚ùå</text>
                    <text x="130" y="260" text-anchor="middle" fill="#6b7280" font-size="10" font-family="Nunito">x‚ÇÅ ‚Üí</text>
                    <text x="18" y="140" fill="#6b7280" font-size="10" font-family="Nunito" transform="rotate(-90,18,140)">x‚ÇÇ ‚Üí</text>
                    <!-- Blue inner cluster -->
                    <circle cx="130" cy="140" r="9" fill="#3b82f6"/><circle cx="115" cy="125" r="9" fill="#3b82f6"/>
                    <circle cx="145" cy="125" r="9" fill="#3b82f6"/><circle cx="120" cy="155" r="9" fill="#3b82f6"/>
                    <circle cx="140" cy="155" r="9" fill="#3b82f6"/><circle cx="130" cy="115" r="9" fill="#3b82f6"/>
                    <!-- Orange outer ring -->
                    <circle cx="70" cy="80" r="9" fill="#f97316"/><circle cx="190" cy="80" r="9" fill="#f97316"/>
                    <circle cx="50" cy="140" r="9" fill="#f97316"/><circle cx="210" cy="140" r="9" fill="#f97316"/>
                    <circle cx="70" cy="200" r="9" fill="#f97316"/><circle cx="190" cy="200" r="9" fill="#f97316"/>
                    <circle cx="110" cy="65" r="9" fill="#f97316"/><circle cx="150" cy="65" r="9" fill="#f97316"/>
                    <circle cx="110" cy="215" r="9" fill="#f97316"/><circle cx="150" cy="215" r="9" fill="#f97316"/>

                    <!-- Arrow -->
                    <path d="M260 140 L340 140" stroke="#7c3aed" stroke-width="3" fill="none" marker-end="url(#arrowPurple)"/>
                    <defs><marker id="arrowPurple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#7c3aed"/></marker></defs>
                    <text x="300" y="125" text-anchor="middle" fill="#7c3aed" font-size="11" font-weight="800" font-family="Nunito">Kernel</text>
                    <text x="300" y="160" text-anchor="middle" fill="#7c3aed" font-size="11" font-weight="800" font-family="Nunito">Trick! ‚ú®</text>

                    <!-- RIGHT: 3D view (now separable!) -->
                    <rect x="360" y="30" width="250" height="220" rx="12" fill="white" stroke="#bbf7d0" stroke-width="2"/>
                    <text x="485" y="25" text-anchor="middle" fill="#16a34a" font-size="13" font-weight="800" font-family="Nunito">3D: Now Separable! ‚úÖ</text>
                    <!-- Separating plane (horizontal line representing the z-plane) -->
                    <line x1="370" y1="150" x2="600" y2="150" stroke="#16a34a" stroke-width="2.5" stroke-dasharray="6,4"/>
                    <text x="485" y="145" text-anchor="middle" fill="#16a34a" font-size="9" font-weight="700" font-family="Nunito">Separating plane</text>
                    <!-- Blue dots lifted UP (high z value) -->
                    <circle cx="460" cy="85" r="9" fill="#3b82f6"/><circle cx="480" cy="75" r="9" fill="#3b82f6"/>
                    <circle cx="500" cy="90" r="9" fill="#3b82f6"/><circle cx="470" cy="100" r="9" fill="#3b82f6"/>
                    <circle cx="490" cy="70" r="9" fill="#3b82f6"/><circle cx="510" cy="95" r="9" fill="#3b82f6"/>
                    <text x="485" y="60" text-anchor="middle" fill="#1d4ed8" font-size="9" font-weight="700" font-family="Nunito">Blue lifted UP ‚¨ÜÔ∏è</text>
                    <!-- Orange dots stay LOW -->
                    <circle cx="400" cy="190" r="9" fill="#f97316"/><circle cx="430" cy="200" r="9" fill="#f97316"/>
                    <circle cx="520" cy="195" r="9" fill="#f97316"/><circle cx="550" cy="185" r="9" fill="#f97316"/>
                    <circle cx="460" cy="210" r="9" fill="#f97316"/><circle cx="500" cy="220" r="9" fill="#f97316"/>
                    <circle cx="380" cy="210" r="9" fill="#f97316"/><circle cx="570" cy="200" r="9" fill="#f97316"/>
                    <text x="485" y="240" text-anchor="middle" fill="#c2410c" font-size="9" font-weight="700" font-family="Nunito">Orange stays LOW ‚¨áÔ∏è</text>
                    <!-- z-axis label -->
                    <text x="600" y="140" fill="#6b7280" font-size="9" font-family="Nunito">z = x‚ÇÅ¬≤+x‚ÇÇ¬≤</text>
                </svg>
                <p style="color: #475569; font-size: 0.92em; margin-top: 10px;">Blue points (close to center) get high z-values when we add feature z = x‚ÇÅ¬≤ + x‚ÇÇ¬≤. Orange points (far from center) get even higher z-values but they spread out. A flat plane at the right height separates them!</p>
            </div>

            <h3>The Magic: Transform to Higher Dimensions!</h3>

            <div class="eli5-box">
                <h4>üé™ The Circus Trick Analogy</h4>
                <p>Imagine blue coins and orange coins scattered on a table. The blue coins are in the center, orange coins surround them. No straight ruler can separate them on the <strong>flat table</strong> (2D).</p>
                <p>Now imagine you <strong>SLAM the table</strong> from below! üí• The coins fly up into the air. The blue coins (lighter) fly higher, the orange ones (heavier) stay lower. NOW, in 3D space, you CAN draw a flat sheet between them!</p>
                <p>That "slamming" is the <strong>kernel trick</strong>. It projects data into a higher dimension where a linear boundary WORKS. The brilliant part? SVM does this <strong>without actually computing</strong> the higher-dimensional coordinates (saving massive computation). It uses a mathematical shortcut called the <strong>kernel function</strong>.</p>
            </div>

            <h3>Types of Kernels</h3>

            <table class="data-table">
                <thead>
                    <tr><th>Kernel</th><th>When to Use</th><th>What It Does</th><th>Speed</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong style="color:#9333ea;">Linear</strong><br><code>kernel='linear'</code></td>
                        <td>Data is (mostly) linearly separable, or you have LOTS of features (text, genomics)</td>
                        <td>No transformation. Just finds the best straight line/plane.</td>
                        <td>Fastest</td>
                    </tr>
                    <tr>
                        <td><strong style="color:#9333ea;">RBF / Gaussian</strong><br><code>kernel='rbf'</code></td>
                        <td>Most common default. Works well when you're not sure about the data shape.</td>
                        <td>Maps to infinite dimensions! Can handle very complex, curvy boundaries.</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td><strong style="color:#9333ea;">Polynomial</strong><br><code>kernel='poly'</code></td>
                        <td>When relationships are polynomial (e.g., x1*x2 or x1^2 matters)</td>
                        <td>Maps to a higher (finite) dimensional space. Controlled by degree parameter.</td>
                        <td>Slower</td>
                    </tr>
                    <tr>
                        <td><strong style="color:#9333ea;">Sigmoid</strong><br><code>kernel='sigmoid'</code></td>
                        <td>Rarely used. Similar to a neural network with one hidden layer.</td>
                        <td>Uses tanh function as the kernel. Mostly for specific research use cases.</td>
                        <td>Medium</td>
                    </tr>
                </tbody>
            </table>

            <button class="reveal-btn" onclick="toggleReveal('rev-kern')"><i class="fas fa-chevron-down"></i> Formula 6: Kernel Functions Math ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-kern">
            <div class="formula-box">
                <h4>üìê Formula 6: The Kernel Functions</h4>
                <p>Each kernel is a function K(x·µ¢, x‚±º) that computes the similarity between two data points ‚Äî but in a HIGHER dimensional space, without actually going there!</p>

                <span class="formula-label">LINEAR KERNEL</span>
                <div class="formula">
                    K(<span class="blue">x·µ¢</span>, <span class="orange">x‚±º</span>) = <span class="blue">x·µ¢</span> ¬∑ <span class="orange">x‚±º</span>
                    <span class="small-note">Just the plain dot product. No transformation at all.</span>
                </div>

                <span class="formula-label">POLYNOMIAL KERNEL</span>
                <div class="formula">
                    K(<span class="blue">x·µ¢</span>, <span class="orange">x‚±º</span>) = (<span class="blue">x·µ¢</span> ¬∑ <span class="orange">x‚±º</span> + r)<sup style="font-size:0.7em;">d</sup>
                    <span class="small-note">r = constant (default 0), d = degree (default 3). Creates polynomial features automatically!</span>
                </div>

                <span class="formula-label">RBF (GAUSSIAN) KERNEL ‚Äî THE STAR ‚≠ê</span>
                <div class="formula">
                    K(<span class="blue">x·µ¢</span>, <span class="orange">x‚±º</span>) = e<sup style="font-size:0.7em;">-<span class="highlight">Œ≥</span> √ó |<span class="blue">x·µ¢</span> - <span class="orange">x‚±º</span>|¬≤</sup>
                    <span class="small-note">Œ≥ (gamma) controls the "reach" of each point. |x·µ¢ - x‚±º|¬≤ is the squared distance between the two points.</span>
                </div>

                <div class="layman-row">
                    <span class="var">e‚ÅªÀ£</span>
                    <span class="meaning">The exponential function. As x gets bigger, e‚ÅªÀ£ gets SMALLER (approaches 0). So distant points ‚Üí kernel value near 0 (very different). Close points ‚Üí kernel value near 1 (very similar).</span>
                </div>
                <div class="layman-row">
                    <span class="var">Œ≥ (gamma)</span>
                    <span class="meaning">Controls the "radius of influence." High gamma = only very close points matter (tight circles). Low gamma = far-away points still matter (wide circles).</span>
                </div>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: RBF Kernel with Two Points</h5>
                    <p>Point A = (1, 2), Point B = (3, 4), gamma = 0.5</p>
                    <div class="calc">
                        |A - B|¬≤ = (1-3)¬≤ + (2-4)¬≤ = 4 + 4 = <strong>8</strong><br>
                        K(A, B) = e<sup>-0.5 √ó 8</sup> = e<sup>-4</sup> ‚âà <strong>0.018</strong> (very different!)<br><br>

                        Now try Point C = (1, 2) and Point D = (1.5, 2.5):<br>
                        |C - D|¬≤ = (0.5)¬≤ + (0.5)¬≤ = 0.25 + 0.25 = <strong>0.5</strong><br>
                        K(C, D) = e<sup>-0.5 √ó 0.5</sup> = e<sup>-0.25</sup> ‚âà <strong>0.78</strong> (very similar!)
                    </div>
                    <p>Points close together ‚Üí high kernel value (similar). Points far apart ‚Üí low kernel value (different). The RBF kernel is basically asking: <strong>"How close are you to your neighbor?"</strong></p>
                </div>
            </div>

            </div><!-- close reveal-content for kernel -->

            <h3>The Gamma Parameter (for RBF Kernel)</h3>
            <p>The <strong>gamma</strong> parameter controls how far the influence of a single training example reaches:</p>

            <div class="comparison-grid">
                <div class="comparison-card">
                    <h5>High Gamma</h5>
                    <p>Each point has very <strong>local</strong> influence. The boundary becomes very wiggly, hugging each point closely. Risk: <strong>overfitting</strong>.</p>
                    <p style="font-size: 0.85em; color: #9333ea; margin-top: 8px;">Like looking at the world through a magnifying glass - you see every tiny detail but miss the big picture.</p>
                </div>
                <div class="comparison-card">
                    <h5>Low Gamma</h5>
                    <p>Each point has very <strong>wide</strong> influence. The boundary is smoother and more general. Risk: <strong>underfitting</strong>.</p>
                    <p style="font-size: 0.85em; color: #9333ea; margin-top: 8px;">Like looking at the world from an airplane - you see the big picture but miss individual details.</p>
                </div>
            </div>

            <div class="key-point">
                <h4>üí° C and Gamma Together</h4>
                <ul>
                    <li><strong>High C + High Gamma</strong> = complex boundary, tight fit ‚Üí likely overfitting</li>
                    <li><strong>Low C + Low Gamma</strong> = simple boundary, loose fit ‚Üí likely underfitting</li>
                    <li>Find the sweet spot with <strong>GridSearchCV</strong>, trying combinations like C=[0.1, 1, 10, 100] and gamma=[0.001, 0.01, 0.1, 1]</li>
                </ul>
            </div>

            <button class="reveal-btn" onclick="toggleReveal('rev-hinge')"><i class="fas fa-chevron-down"></i> Formula 7: Hinge Loss ‚Äî Click to learn</button>
            <div class="reveal-content" id="rev-hinge">
            <div class="formula-box">
                <h4>üìê Formula 7: The Hinge Loss (How SVM Penalizes Mistakes)</h4>
                <p>Internally, SVM uses a special loss function called <strong>Hinge Loss</strong>. Unlike other loss functions, it's happy as long as you're on the right side AND far enough away:</p>

                <span class="formula-label">HINGE LOSS</span>
                <div class="formula">
                    Loss = max(0, 1 - y·µ¢ √ó (<span class="highlight">w</span> ¬∑ <span class="blue">x·µ¢</span> + <span class="orange">b</span>))
                    <span class="small-note">y·µ¢ is the true label (+1 or -1). The loss is 0 when the point is correctly classified AND outside the margin.</span>
                </div>

                <div class="worked-example">
                    <h5>üßÆ Worked Example: When Does the Loss Kick In?</h5>
                    <p>Say we have a positive point (y = +1) and our SVM computes w¬∑x+b for it:</p>
                    <div class="calc">
                        <strong>Case 1:</strong> w¬∑x+b = 2.5 (correct side, far from margin)<br>
                        Loss = max(0, 1 - 1√ó2.5) = max(0, -1.5) = <strong>0</strong> ‚úÖ No penalty!<br><br>

                        <strong>Case 2:</strong> w¬∑x+b = 0.7 (correct side, but INSIDE the margin)<br>
                        Loss = max(0, 1 - 1√ó0.7) = max(0, 0.3) = <strong>0.3</strong> ‚ö†Ô∏è Small penalty<br><br>

                        <strong>Case 3:</strong> w¬∑x+b = -0.5 (WRONG side! misclassified)<br>
                        Loss = max(0, 1 - 1√ó(-0.5)) = max(0, 1.5) = <strong>1.5</strong> üö® Big penalty!
                    </div>
                    <p>Only Case 1 (correctly classified AND outside the margin) gets zero loss. That's why SVM cares about both correctness AND margin distance!</p>
                </div>

                <div class="analogy-box" style="border-color: #eab308;">
                    <h4>üèÉ The Race Lane Analogy</h4>
                    <p>Imagine a running race. The lane marker is the hyperplane, and the "safe zone" is 1 meter beyond the lane. If you're in your lane AND past the safe zone ‚Üí no penalty. If you drift INTO the safe zone but still in your lane ‚Üí small penalty. If you cross into the other runner's lane ‚Üí BIG penalty. That's hinge loss!</p>
                </div>
            </div>
            </div><!-- close reveal-content for hinge loss -->
        </div>

        <!-- ======================================== -->
        <!-- Part 5: SVM for Regression (SVR)         -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-chart-line"></i> Part 5: SVM for Regression (SVR)</h2>

            <p>SVM isn't just for classification! <strong>Support Vector Regression (SVR)</strong> flips the idea: instead of finding the widest margin between classes, it finds a tube (called the <strong>epsilon-tube</strong>) around the prediction line, and tries to fit as many points INSIDE the tube as possible.</p>

            <div class="analogy-box">
                <h4>üöá The Subway Tunnel Analogy</h4>
                <p>Imagine drawing a line through your data (the regression line). Now inflate it into a <strong>tube/tunnel</strong> of width epsilon (Œµ). Points INSIDE the tube? No penalty. Points OUTSIDE the tube? They get penalized (they're errors). SVR finds the line and tube that contains the most points with the flattest (simplest) line possible.</p>
            </div>

            <!-- VISUAL: SVR Epsilon Tube -->
            <div class="svm-visual fade-up">
                <h4>SVR: The Epsilon Tube Around the Prediction Line</h4>
                <svg viewBox="0 0 550 300" xmlns="http://www.w3.org/2000/svg">
                    <rect width="550" height="300" rx="12" fill="#eff6ff"/>
                    <text x="40" y="280" fill="#64748b" font-size="10" font-family="Nunito">Feature (x) ‚Üí</text>
                    <text x="15" y="150" fill="#64748b" font-size="10" font-family="Nunito" transform="rotate(-90,15,150)">Target (y) ‚Üí</text>
                    <!-- Epsilon tube (the shaded band) -->
                    <polygon points="60,220 500,100 500,140 60,260" fill="#dbeafe" stroke="none" opacity="0.6"/>
                    <!-- Prediction line -->
                    <line x1="60" y1="240" x2="500" y2="120" stroke="#2563eb" stroke-width="3"/>
                    <!-- Upper tube boundary -->
                    <line x1="60" y1="220" x2="500" y2="100" stroke="#60a5fa" stroke-width="1.5" stroke-dasharray="5,3"/>
                    <!-- Lower tube boundary -->
                    <line x1="60" y1="260" x2="500" y2="140" stroke="#60a5fa" stroke-width="1.5" stroke-dasharray="5,3"/>
                    <!-- Epsilon label -->
                    <line x1="520" y1="100" x2="520" y2="140" stroke="#7c3aed" stroke-width="2"/>
                    <text x="540" y="124" fill="#7c3aed" font-size="12" font-weight="800" font-family="Nunito">Œµ</text>
                    <!-- Points INSIDE the tube (no penalty - green) -->
                    <circle cx="100" cy="232" r="7" fill="#22c55e"/><circle cx="150" cy="222" r="7" fill="#22c55e"/>
                    <circle cx="200" cy="205" r="7" fill="#22c55e"/><circle cx="250" cy="190" r="7" fill="#22c55e"/>
                    <circle cx="300" cy="175" r="7" fill="#22c55e"/><circle cx="350" cy="162" r="7" fill="#22c55e"/>
                    <circle cx="400" cy="148" r="7" fill="#22c55e"/><circle cx="450" cy="130" r="7" fill="#22c55e"/>
                    <circle cx="130" cy="245" r="7" fill="#22c55e"/><circle cx="330" cy="170" r="7" fill="#22c55e"/>
                    <!-- Points OUTSIDE the tube (penalty! - red) -->
                    <circle cx="180" cy="180" r="8" fill="#ef4444" stroke="#b91c1c" stroke-width="2"/>
                    <circle cx="370" cy="125" r="8" fill="#ef4444" stroke="#b91c1c" stroke-width="2"/>
                    <circle cx="280" cy="210" r="8" fill="#ef4444" stroke="#b91c1c" stroke-width="2"/>
                    <!-- Labels -->
                    <rect x="60" y="30" width="180" height="25" rx="12" fill="#dcfce7"/>
                    <text x="150" y="47" text-anchor="middle" fill="#166534" font-size="11" font-weight="700" font-family="Nunito">üü¢ Inside tube = no penalty</text>
                    <rect x="310" y="30" width="190" height="25" rx="12" fill="#fee2e2"/>
                    <text x="405" y="47" text-anchor="middle" fill="#991b1b" font-size="11" font-weight="700" font-family="Nunito">üî¥ Outside tube = penalty!</text>
                    <text x="275" y="290" text-anchor="middle" fill="#1e40af" font-size="11" font-weight="700" font-family="Nunito">SVR tries to fit the most points INSIDE the tube with the simplest line</text>
                </svg>
            </div>

            <div class="code-block">
<pre><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># Create sample data</span>
np.random.<span class="function">seed</span>(<span class="number">42</span>)
X = np.<span class="function">sort</span>(<span class="number">5</span> * np.random.<span class="function">rand</span>(<span class="number">100</span>, <span class="number">1</span>), axis=<span class="number">0</span>)
y = np.<span class="function">sin</span>(X).<span class="function">ravel</span>() + np.random.<span class="function">normal</span>(<span class="number">0</span>, <span class="number">0.1</span>, X.shape[<span class="number">0</span>])

<span class="comment"># Scale features (ALWAYS scale for SVM!)</span>
scaler = <span class="function">StandardScaler</span>()
X_scaled = scaler.<span class="function">fit_transform</span>(X)

<span class="comment"># Create SVR with RBF kernel</span>
svr = <span class="function">SVR</span>(kernel=<span class="string">'rbf'</span>, C=<span class="number">100</span>, gamma=<span class="number">0.1</span>, epsilon=<span class="number">0.1</span>)
svr.<span class="function">fit</span>(X_scaled, y)

<span class="comment"># Predict</span>
y_pred = svr.<span class="function">predict</span>(X_scaled)
<span class="function">print</span>(<span class="string">f"R¬≤ Score: {svr.score(X_scaled, y):.4f}"</span>)
<span class="function">print</span>(<span class="string">f"Number of support vectors: {len(svr.support_)}"</span>)</pre>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 6: SVM for Multi-Class              -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-layer-group"></i> Part 6: Multi-Class Classification</h2>

            <p>SVM is natively a <strong>binary classifier</strong> (two classes only). But what if you have 3, 5, or 10 classes? Two strategies:</p>

            <div class="comparison-grid">
                <div class="comparison-card">
                    <h5>One-vs-Rest (OvR)</h5>
                    <p>Train K separate SVMs (one for each class). Each SVM asks: "Is this point Class A or Not A?" For 10 classes, train 10 SVMs. Assign the class whose SVM gives the highest confidence.</p>
                    <p style="font-size: 0.85em; color: #9333ea; margin-top: 8px;">Faster, fewer models. Used by <code>LinearSVC</code> by default.</p>
                </div>
                <div class="comparison-card">
                    <h5>One-vs-One (OvO)</h5>
                    <p>Train an SVM for every PAIR of classes. For 10 classes, that's 45 SVMs! Each one votes. The class with the most votes wins.</p>
                    <p style="font-size: 0.85em; color: #9333ea; margin-top: 8px;">More models but each trains on less data. Used by <code>SVC</code> by default.</p>
                </div>
            </div>

            <div class="key-point">
                <h4>üí° Don't Worry About This!</h4>
                <ul>
                    <li>Scikit-learn handles multi-class <strong>automatically</strong>! Just pass your multi-class labels and it picks OvR or OvO internally.</li>
                    <li><code>SVC()</code> uses One-vs-One by default</li>
                    <li><code>LinearSVC()</code> uses One-vs-Rest by default</li>
                </ul>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 7: Feature Scaling                  -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-ruler-combined"></i> Part 7: Feature Scaling (CRITICAL for SVM!)</h2>

            <p>SVM is <strong>extremely sensitive</strong> to feature scales. If one feature ranges from 0-1 and another from 0-1,000,000, the large feature will dominate the distance calculations and the model will be terrible.</p>

            <div class="warning-box">
                <h4>‚ö†Ô∏è ALWAYS Scale Before SVM!</h4>
                <p>This is not optional. SVM REQUIRES scaled features to work properly. Use StandardScaler (zero mean, unit variance) or MinMaxScaler (0 to 1). This is the #1 mistake beginners make with SVM!</p>
            </div>

            <div class="analogy-box">
                <h4>‚öñÔ∏è Why Scaling Matters</h4>
                <p>Imagine comparing houses by "number of bedrooms" (1-5) and "price in dollars" (100,000-5,000,000). Without scaling, the price dominates everything because 5,000,000 >> 5. The bedroom count is essentially ignored! Scaling puts both features on equal footing so SVM can consider them fairly.</p>
            </div>

            <div class="code-block">
<pre><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline
<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC

<span class="comment"># BEST PRACTICE: use a Pipeline so scaling is automatic</span>
svm_pipeline = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svm'</span>, <span class="function">SVC</span>(kernel=<span class="string">'rbf'</span>, C=<span class="number">1.0</span>, gamma=<span class="string">'scale'</span>))
])

<span class="comment"># Now just fit and predict - scaling happens automatically!</span>
svm_pipeline.<span class="function">fit</span>(X_train, y_train)
y_pred = svm_pipeline.<span class="function">predict</span>(X_test)</pre>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 8: Complete Python Example          -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-code"></i> Part 8: Complete SVM in Python (Step by Step)</h2>

            <p>Let's build a complete SVM classifier on a real dataset. We'll use the <strong>Breast Cancer Wisconsin</strong> dataset (built into scikit-learn) to classify tumors as malignant or benign.</p>

            <div class="code-block">
<pre><span class="comment"># ============================================</span>
<span class="comment"># COMPLETE SVM CLASSIFICATION EXAMPLE</span>
<span class="comment"># Dataset: Breast Cancer Wisconsin</span>
<span class="comment"># Goal: Classify tumors as malignant or benign</span>
<span class="comment"># ============================================</span>

<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer
<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, GridSearchCV
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC
<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> (classification_report,
    confusion_matrix, accuracy_score, roc_auc_score)
<span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline

<span class="comment"># ‚îÄ‚îÄ Step 1: Load the data ‚îÄ‚îÄ</span>
data = <span class="function">load_breast_cancer</span>()
X = data.data
y = data.target
<span class="function">print</span>(<span class="string">f"Dataset shape: {X.shape}"</span>)
<span class="function">print</span>(<span class="string">f"Classes: {data.target_names}"</span>)
<span class="function">print</span>(<span class="string">f"Features: {data.feature_names[:5]}..."</span>)

<span class="comment"># ‚îÄ‚îÄ Step 2: Split into train/test ‚îÄ‚îÄ</span>
X_train, X_test, y_train, y_test = <span class="function">train_test_split</span>(
    X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>, stratify=y
)
<span class="function">print</span>(<span class="string">f"\nTrain size: {len(X_train)}, Test size: {len(X_test)}"</span>)

<span class="comment"># ‚îÄ‚îÄ Step 3: Create pipeline (Scale + SVM) ‚îÄ‚îÄ</span>
pipeline = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svm'</span>, <span class="function">SVC</span>(probability=<span class="keyword">True</span>))
])

<span class="comment"># ‚îÄ‚îÄ Step 4: Hyperparameter Tuning with GridSearchCV ‚îÄ‚îÄ</span>
param_grid = {
    <span class="string">'svm__C'</span>: [<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>],
    <span class="string">'svm__gamma'</span>: [<span class="number">0.001</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">1</span>],
    <span class="string">'svm__kernel'</span>: [<span class="string">'rbf'</span>, <span class="string">'linear'</span>]
}

grid_search = <span class="function">GridSearchCV</span>(
    pipeline, param_grid,
    cv=<span class="number">5</span>, scoring=<span class="string">'accuracy'</span>,
    n_jobs=-<span class="number">1</span>, verbose=<span class="number">0</span>
)
grid_search.<span class="function">fit</span>(X_train, y_train)

<span class="function">print</span>(<span class="string">f"\nBest Parameters: {grid_search.best_params_}"</span>)
<span class="function">print</span>(<span class="string">f"Best CV Accuracy: {grid_search.best_score_:.4f}"</span>)

<span class="comment"># ‚îÄ‚îÄ Step 5: Evaluate on test set ‚îÄ‚îÄ</span>
best_model = grid_search.best_estimator_
y_pred = best_model.<span class="function">predict</span>(X_test)
y_proba = best_model.<span class="function">predict_proba</span>(X_test)[:, <span class="number">1</span>]

<span class="function">print</span>(<span class="string">f"\nTest Accuracy: {accuracy_score(y_test, y_pred):.4f}"</span>)
<span class="function">print</span>(<span class="string">f"ROC AUC: {roc_auc_score(y_test, y_proba):.4f}"</span>)
<span class="function">print</span>(<span class="string">f"\nClassification Report:"</span>)
<span class="function">print</span>(<span class="function">classification_report</span>(y_test, y_pred,
    target_names=data.target_names))

<span class="comment"># ‚îÄ‚îÄ Step 6: Check support vectors ‚îÄ‚îÄ</span>
svm_model = best_model.named_steps[<span class="string">'svm'</span>]
<span class="function">print</span>(<span class="string">f"Number of support vectors: {svm_model.n_support_}"</span>)
<span class="function">print</span>(<span class="string">f"Total support vectors: {sum(svm_model.n_support_)}"</span>)
<span class="function">print</span>(<span class="string">f"Out of {len(X_train)} training samples"</span>)</pre>
            </div>

            <div class="key-point">
                <h4>üí° Key Things to Notice</h4>
                <ul>
                    <li>We used a <strong>Pipeline</strong> to combine scaling + SVM (best practice!)</li>
                    <li>We used <strong>GridSearchCV</strong> with 5-fold cross-validation to find the best C, gamma, and kernel</li>
                    <li><code>probability=True</code> enables probability estimates (needed for ROC AUC)</li>
                    <li><code>stratify=y</code> in train_test_split ensures balanced class distribution</li>
                    <li>We checked the number of support vectors - typically a small fraction of total training data</li>
                </ul>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 9: LinearSVC vs SVC                 -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-bolt"></i> Part 9: LinearSVC vs. SVC (When Speed Matters)</h2>

            <p>Scikit-learn offers two SVM classes. Knowing when to use which is key:</p>

            <table class="data-table">
                <thead>
                    <tr><th>Feature</th><th>SVC</th><th>LinearSVC</th></tr>
                </thead>
                <tbody>
                    <tr><td><strong>Kernels</strong></td><td>linear, rbf, poly, sigmoid</td><td>Linear only</td></tr>
                    <tr><td><strong>Speed</strong></td><td>Slower (O(n¬≤) to O(n¬≥))</td><td>Much faster (O(n))</td></tr>
                    <tr><td><strong>Large datasets</strong></td><td>Struggles above 10K-50K samples</td><td>Handles 100K+ easily</td></tr>
                    <tr><td><strong>Multi-class</strong></td><td>One-vs-One (default)</td><td>One-vs-Rest (default)</td></tr>
                    <tr><td><strong>Probabilities</strong></td><td>Yes (with probability=True)</td><td>Not directly (use CalibratedClassifierCV)</td></tr>
                    <tr><td><strong>Best for</strong></td><td>Small-medium data with non-linear boundaries</td><td>Large data, text classification, high-dimensional data</td></tr>
                </tbody>
            </table>

            <div class="code-block">
<pre><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC
<span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler

<span class="comment"># For large datasets or text data, use LinearSVC</span>
fast_svm = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svm'</span>, <span class="function">LinearSVC</span>(C=<span class="number">1.0</span>, max_iter=<span class="number">10000</span>))
])
fast_svm.<span class="function">fit</span>(X_train, y_train)
<span class="function">print</span>(<span class="string">f"Accuracy: {fast_svm.score(X_test, y_test):.4f}"</span>)</pre>
            </div>
        </div>

        <!-- ======================================== -->
        <!-- Part 10: Pros, Cons & When to Use        -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-balance-scale-right"></i> Part 10: Pros, Cons &amp; When to Use SVM</h2>

            <h3>Advantages</h3>
            <div class="key-point">
                <h4>‚úÖ Why SVM is Great</h4>
                <ul>
                    <li><strong>Works in high dimensions</strong> - Even when features outnumber samples (text classification, genomics)</li>
                    <li><strong>Memory efficient</strong> - Only stores support vectors, not all training data</li>
                    <li><strong>Versatile kernels</strong> - RBF kernel handles complex non-linear boundaries beautifully</li>
                    <li><strong>Robust to overfitting</strong> in high-dimensional spaces (with proper C tuning)</li>
                    <li><strong>Works well with clear margin</strong> of separation between classes</li>
                    <li><strong>Effective on small-to-medium datasets</strong> - Often outperforms other algorithms</li>
                </ul>
            </div>

            <h3>Disadvantages</h3>
            <div class="warning-box">
                <h4>‚ùå When SVM Struggles</h4>
                <ul style="margin-left: 22px; color: #991b1b;">
                    <li><strong>Slow on large datasets</strong> - Training time is O(n¬≤) to O(n¬≥) for kernel SVM. 100K+ rows? Use LinearSVC or another algorithm.</li>
                    <li><strong>Sensitive to feature scaling</strong> - MUST scale features (easy to forget!)</li>
                    <li><strong>Hard to interpret</strong> - Unlike decision trees, you can't easily explain "why" a prediction was made</li>
                    <li><strong>Noisy data with overlapping classes</strong> - When classes heavily overlap, SVM may not be the best choice</li>
                    <li><strong>Choosing the right kernel and hyperparameters</strong> - Requires experimentation with GridSearchCV</li>
                    <li><strong>No native probability estimates</strong> - Uses Platt scaling which can be slow</li>
                </ul>
            </div>

            <h3>When Should You Use SVM?</h3>
            <table class="data-table">
                <thead>
                    <tr><th>Scenario</th><th>Use SVM?</th><th>Why / Alternative</th></tr>
                </thead>
                <tbody>
                    <tr><td>Text classification (spam detection)</td><td><strong style="color: #16a34a;">YES</strong></td><td>High-dimensional, sparse data. LinearSVC excels here!</td></tr>
                    <tr><td>Image classification (small dataset)</td><td><strong style="color: #16a34a;">YES</strong></td><td>SVM with RBF kernel works great on small image datasets</td></tr>
                    <tr><td>Tabular data with 1M+ rows</td><td><strong style="color: #dc2626;">NO</strong></td><td>Too slow. Use XGBoost, Random Forest, or neural networks</td></tr>
                    <tr><td>Need to explain predictions</td><td><strong style="color: #dc2626;">NO</strong></td><td>SVM is a black box. Use Decision Trees or Logistic Regression</td></tr>
                    <tr><td>Medical diagnosis (small dataset)</td><td><strong style="color: #16a34a;">YES</strong></td><td>SVM is excellent with small, high-dimensional medical data</td></tr>
                    <tr><td>Binary classification baseline</td><td><strong style="color: #16a34a;">YES</strong></td><td>Great baseline to compare against other models</td></tr>
                    <tr><td>Regression with non-linear patterns</td><td><strong style="color: #f59e0b;">MAYBE</strong></td><td>SVR works but XGBoost/Random Forest often better</td></tr>
                </tbody>
            </table>
        </div>

        <!-- ======================================== -->
        <!-- Part 11: SVM vs Other Algorithms         -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-users"></i> Part 11: SVM vs. Other Algorithms</h2>

            <table class="data-table">
                <thead>
                    <tr><th>Algorithm</th><th>Speed</th><th>Interpretability</th><th>Handles Non-Linear</th><th>Large Data</th><th>Best For</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>SVM (RBF)</strong></td>
                        <td>Slow</td><td>Low</td><td>Excellent</td><td>Poor</td>
                        <td>Small-medium data, clear margins</td>
                    </tr>
                    <tr>
                        <td><strong>Logistic Regression</strong></td>
                        <td>Fast</td><td>High</td><td>No (linear only)</td><td>Good</td>
                        <td>Interpretable linear classification</td>
                    </tr>
                    <tr>
                        <td><strong>kNN</strong></td>
                        <td>Fast train, slow predict</td><td>Medium</td><td>Yes</td><td>Poor</td>
                        <td>Simple baseline, local patterns</td>
                    </tr>
                    <tr>
                        <td><strong>Decision Tree</strong></td>
                        <td>Fast</td><td>Very High</td><td>Yes</td><td>Good</td>
                        <td>Explainable models</td>
                    </tr>
                    <tr>
                        <td><strong>Random Forest</strong></td>
                        <td>Medium</td><td>Medium</td><td>Yes</td><td>Good</td>
                        <td>General purpose, robust</td>
                    </tr>
                    <tr>
                        <td><strong>XGBoost</strong></td>
                        <td>Fast</td><td>Medium</td><td>Yes</td><td>Excellent</td>
                        <td>Competitions, tabular data</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- ======================================== -->
        <!-- Part 12: Summary & Cheat Sheet           -->
        <!-- ======================================== -->
        <div class="section">
            <h2><i class="fas fa-trophy"></i> Part 12: Summary &amp; Cheat Sheet</h2>

            <div class="key-point">
                <h4>üìù Everything You Need to Remember</h4>
                <ul>
                    <li><strong>SVM</strong> finds the hyperplane with the maximum margin between classes. Only <strong>support vectors</strong> (nearest points) matter.</li>
                    <li><strong>C parameter</strong>: High C = strict (overfit risk), Low C = relaxed (underfit risk). Tune with GridSearchCV.</li>
                    <li><strong>Kernel trick</strong>: Projects data into higher dimensions so non-linear data becomes linearly separable. Use <strong>RBF</strong> (default) for non-linear, <strong>linear</strong> for large/high-dimensional data.</li>
                    <li><strong>Gamma parameter</strong> (RBF kernel): High = wiggly boundary (overfit), Low = smooth boundary (underfit).</li>
                    <li><strong>ALWAYS SCALE</strong> your features before SVM. Use <code>StandardScaler</code> inside a <code>Pipeline</code>.</li>
                    <li><strong>SVC</strong> for small-medium data with kernels. <strong>LinearSVC</strong> for large data with linear boundaries.</li>
                    <li><strong>SVR</strong> for regression: fits an epsilon-tube around the prediction line.</li>
                    <li><strong>Best use cases</strong>: text classification, medical data, image classification (small datasets), any problem with clear margins and moderate data size.</li>
                    <li><strong>Avoid when</strong>: dataset is very large (100K+ rows), you need interpretability, or classes heavily overlap.</li>
                </ul>
            </div>

            <div class="code-block">
<pre><span class="comment"># ‚îÄ‚îÄ QUICK REFERENCE CHEAT SHEET ‚îÄ‚îÄ</span>

<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC, LinearSVC, SVR
<span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler
<span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline

<span class="comment"># Classification with RBF kernel (small-medium data)</span>
clf = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svm'</span>, <span class="function">SVC</span>(kernel=<span class="string">'rbf'</span>, C=<span class="number">1</span>, gamma=<span class="string">'scale'</span>))
])

<span class="comment"># Fast linear classification (large data, text)</span>
clf_fast = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svm'</span>, <span class="function">LinearSVC</span>(C=<span class="number">1</span>, max_iter=<span class="number">10000</span>))
])

<span class="comment"># Regression</span>
reg = <span class="function">Pipeline</span>([
    (<span class="string">'scaler'</span>, <span class="function">StandardScaler</span>()),
    (<span class="string">'svr'</span>, <span class="function">SVR</span>(kernel=<span class="string">'rbf'</span>, C=<span class="number">100</span>, epsilon=<span class="number">0.1</span>))
])</pre>
            </div>

            <p style="margin-top: 20px;">Next, head to <a href="decision-trees.html" style="color: #9333ea; font-weight: 700;">Decision Trees & Random Forests</a> to learn about tree-based models, or go back to <a href="k-nearest-neighbors.html" style="color: #9333ea; font-weight: 700;">kNN</a> to compare approaches.</p>
        </div>

        <div class="nav-buttons">
            <a href="k-nearest-neighbors.html" class="nav-btn prev"><i class="fas fa-arrow-left"></i> Previous: kNN</a>
            <a href="decision-trees.html" class="nav-btn next">Next: Decision Trees <i class="fas fa-arrow-right"></i></a>
        </div>
    </div>

    <button class="back-to-top" id="backToTop"><i class="fas fa-arrow-up"></i></button>
    <script>
        // Back to top
        const backToTopButton = document.getElementById('backToTop');
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) backToTopButton.classList.add('show');
            else backToTopButton.classList.remove('show');
        });
        backToTopButton.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

        // Fade-in on scroll
        const fadeObserver = new IntersectionObserver((entries) => {
            entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
        }, { threshold: 0.1 });
        document.querySelectorAll('.fade-up, .section').forEach(el => {
            el.classList.add('fade-up');
            fadeObserver.observe(el);
        });

        // Click-to-reveal math
        function toggleReveal(id) {
            const el = document.getElementById(id);
            el.classList.toggle('open');
            const btn = el.previousElementSibling;
            const icon = btn.querySelector('i');
            if (el.classList.contains('open')) {
                icon.className = 'fas fa-chevron-up';
                btn.innerHTML = btn.innerHTML.replace('Click to learn', 'Click to hide');
            } else {
                icon.className = 'fas fa-chevron-down';
                btn.innerHTML = btn.innerHTML.replace('Click to hide', 'Click to learn');
            }
        }

        // Interactive: Show different boundaries
        function showBoundary(type) {
            const line = document.getElementById('tryLine');
            const margin = document.getElementById('tryMargin');
            const label = document.getElementById('tryLabel');

            if (type === 'bad1') {
                line.setAttribute('x1', '200'); line.setAttribute('x2', '200');
                line.setAttribute('stroke', '#ef4444');
                margin.setAttribute('x', '170'); margin.setAttribute('width', '60');
                margin.setAttribute('fill', '#ef4444');
                label.textContent = '‚ùå Bad! Too close to blue. Tiny margin.';
                label.setAttribute('fill', '#b91c1c');
            } else if (type === 'bad2') {
                line.setAttribute('x1', '330'); line.setAttribute('x2', '330');
                line.setAttribute('stroke', '#ef4444');
                margin.setAttribute('x', '310'); margin.setAttribute('width', '50');
                margin.setAttribute('fill', '#ef4444');
                label.textContent = '‚ùå Bad! Too close to orange. Tiny margin.';
                label.setAttribute('fill', '#b91c1c');
            } else {
                line.setAttribute('x1', '260'); line.setAttribute('x2', '260');
                line.setAttribute('stroke', '#7c3aed');
                margin.setAttribute('x', '190'); margin.setAttribute('width', '140');
                margin.setAttribute('fill', '#a855f7');
                label.textContent = '‚úÖ Best! Maximum margin ‚Äî SVM picks this one!';
                label.setAttribute('fill', '#6d28d9');
            }
        }

        // Interactive: C parameter slider
        function updateCSlider(val) {
            const cVal = (val / 50).toFixed(1);
            document.getElementById('cVal').textContent = 'C = ' + cVal;
            const line = document.getElementById('cLine');
            const margin = document.getElementById('cMargin');
            const text = document.getElementById('cText');
            const outlier = document.getElementById('cOutlier');

            const marginWidth = 40 + (100 - val) * 1.2;
            const lineX = 260 + (val - 50) * 0.3;

            line.setAttribute('x1', lineX);
            line.setAttribute('x2', lineX);
            margin.setAttribute('x', lineX - marginWidth / 2);
            margin.setAttribute('width', marginWidth);

            if (val < 30) {
                text.textContent = 'C = ' + cVal + ' ‚Äî Wide margin, tolerates outlier ‚úÖ';
                outlier.setAttribute('opacity', '0.7');
                outlier.setAttribute('fill', '#60a5fa');
            } else if (val > 70) {
                text.textContent = 'C = ' + cVal + ' ‚Äî Narrow margin, no tolerance! ‚ö†Ô∏è';
                outlier.setAttribute('opacity', '1');
                outlier.setAttribute('fill', '#f87171');
            } else {
                text.textContent = 'C = ' + cVal + ' ‚Äî Balanced margin';
                outlier.setAttribute('opacity', '0.8');
                outlier.setAttribute('fill', '#60a5fa');
            }
        }
    </script>
</body>
</html>
