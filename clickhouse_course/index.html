<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClickHouse Course | Fakhruddin Khambaty's Learning Hub</title>
    <link rel="stylesheet" href="../css/fkti-light-theme.css">
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .content-section { display: none; padding: 40px 0; }
        .content-section.active { display: block; }
        .screenshot-placeholder { background: #fef9c3; border: 2px dashed #eab308; border-radius: 12px; padding: 24px; margin: 20px 0; text-align: center; color: #713f12; }
        .screenshot-placeholder h4 { color: #a16207; margin-bottom: 10px; }
        .mock-screenshot { background: #fef08a; border-radius: 8px; padding: 20px; min-height: 120px; }
        .step-by-step .step { display: flex; gap: 20px; margin-bottom: 30px; align-items: flex-start; }
        .step-number { width: 48px; height: 48px; background: linear-gradient(135deg, #eab308 0%, #ca8a04 100%); color: #1e293b; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; flex-shrink: 0; }
        .eli5-box { background: linear-gradient(135deg, #fef9c3 0%, #fef08a 100%); border-radius: 20px; padding: 30px; margin: 25px 0; border: 3px dashed #ca8a04; }
        .eli5-box h4 { color: #713f12; }
        .code-block { background: #0f172a; color: #f8fafc; padding: 20px; border-radius: 12px; overflow-x: auto; font-family: 'Fira Code', monospace; font-weight: 500; }
        .code-block pre { margin: 0; color: #f8fafc; }
        .terminal-mock { background: #0f172a; color: #f8fafc; border-radius: 8px; padding: 16px 20px; font-family: 'Fira Code', monospace; font-size: 0.95em; overflow-x: auto; border: 1px solid #334155; font-weight: 500; }
        .terminal-mock .prompt { color: #22c55e; font-weight: 600; }
        .terminal-mock .output { color: #e2e8f0; }
        .terminal-mock pre { color: inherit; }
        .browser-mock { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .browser-mock .browser-bar { background: #f3f4f6; padding: 8px 12px; font-size: 12px; color: #6b7280; border-bottom: 1px solid #e5e7eb; }
        .browser-mock .browser-body { padding: 20px; font-family: 'Fira Code', monospace; font-size: 14px; color: #1e293b; }
        .diagram-box { background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; padding: 24px; margin: 20px 0; font-family: 'Fira Code', monospace; font-size: 0.85em; line-height: 1.6; color: #334155; overflow-x: auto; }
        .what-you-see { background: #ecfdf5; border-left: 4px solid #22c55e; padding: 16px 20px; margin: 16px 0; border-radius: 0 8px 8px 0; }
        .what-you-see h4 { color: #166534; margin-bottom: 8px; font-size: 1em; }
        .key-takeaway { background: #eff6ff; border-left: 4px solid #2563eb; padding: 16px 20px; margin: 20px 0; border-radius: 0 10px 10px 0; }
        .key-takeaway h4 { color: #1e40af; margin-bottom: 8px; font-size: 1em; }
        .tip-box { background: #f0fdf4; border-left: 4px solid #22c55e; padding: 16px 20px; margin: 20px 0; border-radius: 0 10px 10px 0; }
        .tip-box h4 { color: #166534; margin-bottom: 8px; font-size: 1em; }
        .subsection { margin-top: 32px; }
        .subsection h4 { font-size: 1.1em; color: #1e293b; margin-bottom: 10px; }
        .img-placeholder { background: linear-gradient(135deg, #fef9c3 0%, #fde68a 100%); border: 2px solid #eab308; border-radius: 12px; padding: 24px; margin: 20px 0; text-align: center; color: #713f12; min-height: 180px; display: flex; flex-direction: column; justify-content: center; }
        .img-placeholder .img-title { font-weight: 700; color: #a16207; margin-bottom: 8px; }
        .img-placeholder .img-desc { font-size: 0.95em; line-height: 1.5; }
        .source-cite { font-size: 0.9em; color: #64748b; margin-top: 12px; font-style: italic; }
        /* Nav: high contrast + all buttons visible (no fixed height clip) */
        #navbar { background: #1e293b !important; padding: 12px 0 !important; }
        #navbar .container { height: auto !important; min-height: 48px !important; flex-wrap: wrap !important; padding: 12px 20px !important; align-content: center !important; }
        #navbar .nav-btn { color: #ffffff !important; background: rgba(255,255,255,0.15) !important; border: 1px solid rgba(255,255,255,0.3) !important; font-weight: 600 !important; font-size: 13px !important; padding: 10px 14px !important; white-space: nowrap !important; }
        #navbar .nav-btn:hover { background: rgba(255,255,255,0.3) !important; color: #ffffff !important; }
    </style>
</head>
<body>
    <header style="background: linear-gradient(135deg, #eab308 0%, #ca8a04 50%, #a16207 100%); color: #1e293b; padding: 20px 0;">
        <div class="container">
            <div style="display: flex; align-items: center; gap: 20px;">
                <span style="font-size: 2.5rem;">âš¡</span>
                <div>
                    <h1 style="margin: 0;">ClickHouse â€“ Analytics at Speed</h1>
                    <p style="margin: 5px 0 0; opacity: 0.9;">FKTI â€“ Explained like you're 5. Install with Docker on Mac, step by step.</p>
                </div>
            </div>
        </div>
    </header>

    <nav id="navbar" style="background: #1e293b; padding: 12px 0; position: sticky; top: 0; z-index: 100;">
        <div class="container" style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center; height: auto; min-height: 48px;">
            <a href="../index.html" style="background: rgba(255,255,255,0.2); color: #ffffff; border: 1px solid rgba(255,255,255,0.35); padding: 10px 14px; border-radius: 8px; font-weight: 600; text-decoration: none;">Home</a>
            <button class="nav-btn" onclick="window.location.href='hub.html'" style="background: rgba(255,255,255,0.2); color: #ffffff; border: 1px solid rgba(255,255,255,0.35); padding: 10px 14px; border-radius: 8px; cursor: pointer; font-weight: 600;">â† Course Hub</button>
            <button class="nav-btn" onclick="showSection('welcome')">ğŸ  Welcome</button>
            <button class="nav-btn" onclick="showSection('what-is-ch')">ğŸ‘¶ What is ClickHouse</button>
            <button class="nav-btn" onclick="showSection('why-fast')">âš¡ Why So Fast</button>
            <button class="nav-btn" onclick="showSection('history-benchmarks')">ğŸ“Š History &amp; Benchmarks</button>
            <button class="nav-btn" onclick="showSection('install-docker-mac')">âš™ï¸ Install (Docker Mac)</button>
            <button class="nav-btn" onclick="showSection('tables-types')">ğŸ“‹ Tables &amp; Types</button>
            <button class="nav-btn" onclick="showSection('sql-basics')">ğŸ”¤ SQL Basics</button>
            <button class="nav-btn" onclick="showSection('aggregations')">ğŸ“Š Aggregations</button>
            <button class="nav-btn" onclick="showSection('window-functions')">ğŸªŸ Window Functions</button>
            <button class="nav-btn" onclick="showSection('realtime-integrations')">ğŸ”Œ Real-time</button>
        </div>
    </nav>

    <main class="container" style="padding: 30px 20px; max-width: 900px; margin: 0 auto;">

        <!-- Welcome -->
        <section id="welcome" class="content-section active">
            <h2>ğŸ¯ Welcome to the ClickHouse Course</h2>
            <p>This course is designed to <strong>hand-hold you from zero to confident</strong>. You will learn what ClickHouse is, why itâ€™s fast, how to install and run it, and then how to create tables, write SQL, use aggregations and window functions, and connect it to the rest of your stack. Each section builds on the previous one, with clear examples and explanations.</p>

            <h3>What youâ€™ll learn (course outline)</h3>
            <ol style="margin-left: 22px; line-height: 2;">
                <li><strong>What is ClickHouse?</strong> â€“ Database for analytics, row vs column storage, when to use it.</li>
                <li><strong>Why is it so fast?</strong> â€“ Columnar storage, pruning, vectorized execution, parts and merges.</li>
                <li><strong>History &amp; benchmarks</strong> â€“ Where it came from and real-world performance numbers.</li>
                <li><strong>Install with Docker on Mac</strong> â€“ Step-by-step so you have a running server and can run your first query.</li>
                <li><strong>Tables and data types</strong> â€“ How to create tables, choose types, use MergeTree, ORDER BY and PARTITION BY.</li>
                <li><strong>SQL basics</strong> â€“ SELECT, WHERE, ORDER BY, LIMIT, with several examples you can run yourself.</li>
                <li><strong>Aggregations</strong> â€“ SUM, COUNT, AVG, GROUP BY, HAVING, and ClickHouse-specific functions.</li>
                <li><strong>Window functions</strong> â€“ PARTITION BY, ORDER BY in windows, ROW_NUMBER, RANK, LAG/LEAD.</li>
                <li><strong>Real-time and integrations</strong> â€“ Inserting data via HTTP, dashboards, and pipelines.</li>
            </ol>

            <div class="eli5-box">
                <h4>In one sentence</h4>
                <p>ClickHouse is a database that answers analytics questions (sums, counts, trends) very fast over huge data â€“ events, logs, sales â€“ often in milliseconds. Youâ€™ll learn how to run it, model data, and query it like a pro.</p>
            </div>

            <h3>What youâ€™ll see after installation</h3>
            <p>Once ClickHouse is running (weâ€™ll do that in the Install section), youâ€™ll open <code>http://localhost:8123</code> in your browser. Youâ€™ll see:</p>
            <div class="browser-mock">
                <div class="browser-bar">localhost:8123</div>
                <div class="browser-body">Ok.</div>
            </div>
            <p>That single word <strong>Ok.</strong> means the server is running. You can send a SQL query (e.g. <code>SELECT 1+1</code>) and get the result (<code>2</code>). Weâ€™ll do that together in the Install section. Letâ€™s start with understanding what ClickHouse is.</p>
        </section>

        <!-- What is ClickHouse (ELI5) -->
        <section id="what-is-ch" class="content-section">
            <h2>ğŸ‘¶ What is ClickHouse?</h2>
            <p>ClickHouse is a <strong>database built for analytics</strong>. Unlike the database that powers your app (where you read and update one row at a time), ClickHouse is built for questions like: â€œWhat was our total revenue last month?â€, â€œHow many events per country in the last hour?â€, â€œWhatâ€™s the 99th percentile latency?â€ over <strong>huge amounts of data</strong> â€“ billions of rows â€“ and it answers them very fast, often in milliseconds.</p>

            <h3>Why â€œanalyticsâ€ is different</h3>
            <p>In an analytics workload you usually <strong>add new rows</strong> (events, logs, sales) and then <strong>run queries that scan and aggregate</strong> (SUM, COUNT, AVG, GROUP BY). You rarely â€œupdate one rowâ€ or â€œdelete one row.â€ ClickHouse is optimized for exactly that: lots of inserts and heavy read queries that touch many rows and many columns.</p>

            <h3>The main idea: columnar storage</h3>
            <p>Most databases (PostgreSQL, MySQL) store data <strong>row by row</strong>: each row is stored as one block (id, name, revenue, date together). So to get â€œsum of revenue,â€ the engine has to read <em>every row</em> and then take the revenue column. ClickHouse stores data <strong>column by column</strong>: all revenue values are stored together, all dates together, and so on. So when you ask for <code>SUM(revenue)</code>, it only reads the revenue column â€“ much less data from disk, so the query is much faster.</p>
            <div class="diagram-box">
<pre>ROW STORE (e.g. PostgreSQL)       COLUMNAR STORE (ClickHouse)
Row1: [id, name, revenue, date]    Column revenue: [100, 200, 150, ...]
Row2: [id, name, revenue, date]   Column date:    [2024-01-01, ...]
Row3: [id, name, revenue, date]   Column name:   [Alice, Bob, ...]

SUM(revenue) â†’ read every row,     SUM(revenue) â†’ read only the
then take revenue.                 revenue column. âœ“ Much faster.</pre>
            </div>

            <h3>Real use cases</h3>
            <p>People use ClickHouse for:</p>
            <ul style="margin-left: 22px; line-height: 1.9;">
                <li><strong>Web and product analytics</strong> â€“ clicks, page views, funnels (e.g. Yandex.Metrica).</li>
                <li><strong>Logs and events</strong> â€“ application logs, error tracking, user actions.</li>
                <li><strong>IoT and sensors</strong> â€“ time-series from devices (temperature, usage, telemetry).</li>
                <li><strong>Business metrics</strong> â€“ revenue by region, sales by product, dashboards.</li>
            </ul>

            <div class="eli5-box">
                <h4>When to use ClickHouse â€“ and when not to</h4>
                <p><strong>Use ClickHouse when:</strong> you have (or will have) a lot of events, logs, or metrics; you need fast aggregations (SUM, COUNT, AVG) and filters over that data; and youâ€™re okay with â€œmostly insert, sometimes queryâ€ â€“ not updating single rows constantly.</p>
                <p><strong>Donâ€™t use it for:</strong> your main application database where you constantly read/update one row (e.g. user profile, order status, shopping cart). For that, use PostgreSQL, MySQL, or similar. ClickHouse is the wrong tool for high-frequency single-row updates.</p>
            </div>
            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>ClickHouse = analytics database. Columnar storage = read only the columns you need = fast SUM/COUNT/AVG over billions of rows. Use it for events, logs, metrics; not for â€œget/update one user row.â€</p>
            </div>
        </section>

        <!-- Why is ClickHouse so fast? (simplified from 261.pdf / HTW Dresden) -->
        <section id="why-fast" class="content-section">
            <h2>âš¡ Why Is It So Fast?</h2>
            <p>ClickHouse is built so that analytics queries over huge tables run in milliseconds instead of minutes. Here are the four main ideas (simplified from how the engine actually works). You donâ€™t need to remember every detail â€“ just get the intuition: <strong>read less, do more per CPU cycle, and donâ€™t block reads with writes.</strong></p>

            <h3>1. Columnar storage â€“ read only what you need</h3>
            <p>We already said: ClickHouse stores by column. So <code>SUM(revenue)</code> only reads the <code>revenue</code> column from disk, not every column of every row. That means <strong>less data to read</strong>. On top of that, values in one column are often similar (e.g. many repeated dates or small integers), so they <strong>compress very well</strong>. Less data and better compression mean faster reads and lower storage cost.</p>

            <h3>2. Skip what you donâ€™t need â€“ pruning</h3>
            <p>ClickHouse doesnâ€™t blindly scan every row. Data is <strong>sorted</strong> by a key (you choose it when you create the table, e.g. <code>ORDER BY date</code>). So when you run <code>WHERE date &gt;= '2024-01-01'</code>, the engine can <strong>skip whole chunks</strong> of data that only contain older dates. There are also â€œskipping indexesâ€ (e.g. min/max per block): if a blockâ€™s maximum value is 10 and your query asks for <code>clicks &gt; 15</code>, that block is skipped. The slogan: <em>the fastest scan is not scanning at all.</em></p>

            <h3>3. Vectorized execution (SIMD)</h3>
            <p>Instead of â€œadd two numbers, then two more, then two more,â€ the CPU can do the same operation on <strong>8 or 16 numbers at once</strong> (SIMD: Single Instruction, Multiple Data). ClickHouse uses this for aggregations: summing millions of rows becomes a tight loop over chunks of 8 or 16 values. Thatâ€™s why <code>SUM(...)</code> over a billion rows can still be very fast.</p>

            <h3>4. Parts and merges â€“ append-friendly storage</h3>
            <p>New data is written into <strong>parts</strong>: sorted, immutable files. So inserts donâ€™t rewrite existing data and donâ€™t block reads. In the background, ClickHouse <strong>merges</strong> small parts into bigger ones (and can do things like â€œkeep only the latest row per keyâ€ or â€œdelete old data by TTLâ€). You get fast writes and fast reads at the same time.</p>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Fast = (1) read only the columns you use, (2) skip chunks that canâ€™t match your filter, (3) use the CPU in bulk (SIMD), (4) write to new parts so reads stay fast. When you create tables and write queries, thinking â€œcolumn-firstâ€ and â€œfilter by the sort keyâ€ will help you get the best performance.</p>
            </div>
        </section>

        <!-- History and benchmarks (from 261.pdf + Lund 2022-14 thesis) -->
        <section id="history-benchmarks" class="content-section">
            <h2>ğŸ“Š History &amp; Real Numbers</h2>

            <h3>Where ClickHouse came from</h3>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li><strong>2009</strong> â€“ Built at Yandex for web analytics (Yandex.Metrica).</li>
                <li><strong>2016</strong> â€“ Open-sourced; docs in English and others.</li>
                <li><strong>2021</strong> â€“ ClickHouse, Inc. created; company valued at ~<strong>$2B</strong>.</li>
            </ul>

            <h3>OLAP vs OLTP</h3>
            <p>ClickHouse is for <strong>OLAP</strong> (analytics), not OLTP (day-to-day transactions).</p>
            <div class="diagram-box">
<pre>OLTP (PostgreSQL, MySQL)     OLAP (ClickHouse)
Short queries, many updates   Long queries, few updates
Row storage                   Column storage
"Get one user"               "Sum revenue by region"</pre>
            </div>

            <h3>Benchmarks (Lund University study)</h3>
            <p>A Masterâ€™s thesis compared ClickHouse, Elasticsearch, and MinIO on real IoT-style data (billions of rows). In short:</p>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li><strong>Ingest:</strong> ClickHouse ~21Ã— faster than Elasticsearch.</li>
                <li><strong>Storage:</strong> ClickHouse used ~3Ã— less disk than Elasticsearch.</li>
                <li><strong>Queries:</strong> ClickHouse 5â€“14Ã— faster in most aggregation tests.</li>
            </ul>
            <p>So â€œClickHouse is fastâ€ is backed by real experiments, not just marketing. (Source: GÃ¶ransson &amp; WÃ¤ndesjÃ¶, Lund 2022.)</p>
            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>ClickHouse came from Yandex (2009), went open source (2016), and is now a $2B company. Itâ€™s built for OLAP (analytics), not OLTP. Independent benchmarks show itâ€™s much faster than Elasticsearch for ingest, storage, and typical analytics queries.</p>
            </div>
        </section>

        <!-- Install ClickHouse with Docker on Mac -->
        <section id="install-docker-mac" class="content-section">
            <h2>âš™ï¸ Install with Docker on Mac</h2>
            <p>We use <strong>Docker</strong> on a <strong>Mac</strong>. Docker runs ClickHouse in a container so you donâ€™t have to install it directly on your system. Follow each step and use the screenshots to confirm youâ€™re in the right place.</p>

            <div class="step-by-step">
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Install Docker Desktop for Mac (if needed)</h4>
                        <p>If you don't have Docker yet, download it from <a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noopener">docker.com/products/docker-desktop</a>. Choose the Mac version (Apple Silicon or Intel). Install and open Docker Desktop; wait until it says â€œEngine running.â€</p>
                        <div class="what-you-see">
                            <h4>What you'll see</h4>
                            <p>Docker Desktop shows a whale icon in the menu bar. When you open the app, the left sidebar shows <strong>Containers</strong>, <strong>Images</strong>, and at the bottom a green dot or â€œEngine running.â€ The main area may show â€œNo containers runningâ€ or a quick-start message. Thatâ€™s correctâ€”we'll run our first container in Step 4.</p>
                        </div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Open Terminal</h4>
                        <p>On your Mac, open <strong>Terminal</strong> (Applications â†’ Utilities â†’ Terminal, or press Cmd+Space and type â€œTerminalâ€). You'll run all commands here.</p>
                        <div class="terminal-mock">
                            <div class="prompt">user@MacBook-Pro ~ %</div>
                        </div>
                        <p>The prompt usually shows your username, machine name, current directory (~ = home), and <code>%</code> (or <code>$</code>). Type the commands in the steps below at this prompt.</p>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Pull the ClickHouse image</h4>
                        <p>Download the official ClickHouse server image from Docker Hub:</p>
                        <div class="code-block">
                            <pre>docker pull clickhouse/clickhouse-server</pre>
                        </div>
                        <p>Wait until the download finishes. You'll see â€œStatus: Downloaded newer image for clickhouse/clickhouse-server:latestâ€ (or a version tag).</p>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> docker pull clickhouse/clickhouse-server
<span class="output">latest: Pulling from clickhouse/clickhouse-server
a1b2c3d4e5f6: Pull complete
...
Status: Downloaded newer image for clickhouse/clickhouse-server:latest</span></pre>
                        </div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Run ClickHouse in a container</h4>
                        <p>Start a ClickHouse server that listens on port <code>8123</code> (HTTP) and <code>9000</code> (native). We give the container a name so we can stop it later:</p>
                        <div class="code-block">
                            <pre>docker run -d --name clickhouse-server \
  -p 8123:8123 -p 9000:9000 \
  clickhouse/clickhouse-server</pre>
                        </div>
                        <p><code>-d</code> = run in background. <code>--name clickhouse-server</code> = name of the container. <code>-p 8123:8123</code> = map port 8123 (HTTP interface).</p>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> docker run -d --name clickhouse-server \
  -p 8123:8123 -p 9000:9000 \
  clickhouse/clickhouse-server
<span class="output">a7f3b2c1d4e5968708192f3b4c5d6e7f8a9b0c1d2</span></pre>
                        </div>
                        <p>The long string is the container ID. Your ID will differ; that's normal. The container is now running in the background.</p>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Check that the container is running</h4>
                        <p>List running containers:</p>
                        <div class="code-block">
                            <pre>docker ps</pre>
                        </div>
                        <p>You should see <code>clickhouse-server</code> with status â€œUpâ€ and ports â€œ0.0.0.0:8123->8123/tcpâ€.</p>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> docker ps
<span class="output">CONTAINER ID   IMAGE                         STATUS         PORTS
a7f3b2c1d4e5   clickhouse/clickhouse-server   Up 2 minutes   0.0.0.0:8123->8123/tcp, 0.0.0.0:9000->9000/tcp
NAMES
clickhouse-server</span></pre>
                        </div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">6</div>
                    <div class="step-content">
                        <h4>Test the HTTP interface</h4>
                        <p>ClickHouse has a simple HTTP API. In your browser, open:</p>
                        <p><code>http://localhost:8123</code></p>
                        <p>You should see a plain â€œOk.â€ or similar. Or from Terminal:</p>
                        <div class="code-block">
                            <pre>curl http://localhost:8123</pre>
                        </div>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> curl http://localhost:8123
<span class="output">Ok.</span></pre>
                        </div>
                        <p>In the browser, the page body is just the word <strong>Ok.</strong> (no HTML). That confirms ClickHouse's HTTP interface is up.</p>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">7</div>
                    <div class="step-content">
                        <h4>Run a simple SQL query</h4>
                        <p>Send a query via HTTP:</p>
                        <div class="code-block">
                            <pre>curl 'http://localhost:8123/?query=SELECT%201%2B1'</pre>
                        </div>
                        <p>You should get <code>2</code> in the response. Or use the clickhouse-client inside the container:</p>
                        <div class="code-block">
                            <pre>docker exec -it clickhouse-server clickhouse-client --query "SELECT 1+1"</pre>
                        </div>
                        <p>Expected output: <code>2</code>.</p>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> curl 'http://localhost:8123/?query=SELECT%201%2B1'
<span class="output">2</span></pre>
                        </div>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> docker exec -it clickhouse-server clickhouse-client --query "SELECT 1+1"
<span class="output">2</span></pre>
                        </div>
                        <p>Both methods return <strong>2</strong>. Your ClickHouse server is working and answering SQL.</p>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">8</div>
                    <div class="step-content">
                        <h4>Optional: Install clickhouse-client on your Mac</h4>
                        <p>To run <code>clickhouse-client</code> directly on your Mac (without docker exec), you can install it with Homebrew:</p>
                        <div class="code-block">
                            <pre>brew install clickhouse</pre>
                        </div>
                        <p>Then connect to the server in Docker:</p>
                        <div class="code-block">
                            <pre>clickhouse-client --host localhost</pre>
                        </div>
                        <p>You get an interactive prompt. Run a couple of queries to confirm:</p>
                        <div class="terminal-mock">
<pre><span class="prompt">user@MacBook-Pro ~ %</span> clickhouse-client --host localhost
<span class="output">ClickHouse client version 24.x.x.
Connecting to localhost:9000 as user default.
Connected to ClickHouse server.</span>

<span class="prompt">localhost :)</span> SELECT 1
<span class="output">1</span>

<span class="prompt">localhost :)</span> SELECT now()
<span class="output">2024-02-14 12:34:56</span></pre>
                        </div>
                        <p>The <code>localhost :)</code> prompt means you're connected. Type your SQL and press Enter; results appear below. Type <code>quit</code> or press Ctrl+D to exit.</p>
                    </div>
                </div>

                <div class="step">
                    <div class="step-number">9</div>
                    <div class="step-content">
                        <h4>Stopping and starting the server</h4>
                        <p>To stop ClickHouse when you're done:</p>
                        <div class="code-block">
                            <pre>docker stop clickhouse-server</pre>
                        </div>
                        <p>To start it again later (your data is still there if you used a volume, or itâ€™s gone if you didnâ€™t):</p>
                        <div class="code-block">
                            <pre>docker start clickhouse-server</pre>
                        </div>
                        <p>To remove the container (and lose data inside it): <code>docker rm -f clickhouse-server</code>. For real use, run the container with a volume so data persists: add <code>-v /path/on/mac:/var/lib/clickhouse</code> to the <code>docker run</code> command.</p>
                        <div class="tip-box">
                            <h4>Next</h4>
                            <p>Go to <strong>Tables and Data Types</strong> and create your first table, then run the INSERT and SELECT examples. Thatâ€™s how youâ€™ll use ClickHouse every day.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Tables & Data Types -->
        <section id="tables-types" class="content-section">
            <h2>ğŸ“‹ Tables and Data Types</h2>
            <p>In ClickHouse, all data lives in <strong>tables</strong>. Each column has a <strong>type</strong> (number, string, date, etc.). Tables are stored in a columnar way, so reading one column across many rows is very fast. This section teaches you how to create tables, choose types, and understand the options that affect performance.</p>

            <h3>Creating your first table</h3>
            <p>You need: (1) table name, (2) column names and types, (3) an <strong>engine</strong>, and (4) for MergeTree, an <strong>ORDER BY</strong> (how rows are sorted on disk). Hereâ€™s a minimal example:</p>
            <div class="code-block">
                <pre>CREATE TABLE events (
  time DateTime,
  name String,
  value Float64
) ENGINE = MergeTree()
ORDER BY time;</pre>
            </div>
            <p><strong>What this does:</strong> Creates a table <code>events</code> with three columns. <code>ENGINE = MergeTree()</code> is the standard engine for analytics (weâ€™ll come back to it). <code>ORDER BY time</code> means data is sorted by <code>time</code> on disk â€“ so queries like â€œlast 7 daysâ€ can skip old data quickly.</p>

            <h3>Engine: MergeTree</h3>
            <p>ClickHouse has several table engines. For learning and for most analytics, you use <strong>MergeTree</strong>. MergeTree tables:</p>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li>Store data in parts (sorted by the key you give in <code>ORDER BY</code>).</li>
                <li>Merge parts in the background to keep the number of parts under control.</li>
                <li>Support fast inserts and fast range queries (e.g. by time).</li>
            </ul>
            <p>Other engines (e.g. Log, Memory) exist for special cases; for now stick with MergeTree.</p>

            <h3>ORDER BY â€“ the â€œprimary keyâ€ for sorting</h3>
            <p><code>ORDER BY</code> is required for MergeTree. It defines the order of rows on disk. Queries that filter or sort by a <strong>prefix</strong> of this key are very efficient (e.g. <code>ORDER BY (date, user_id)</code> makes <code>WHERE date = today()</code> and <code>ORDER BY date, user_id</code> fast). You can use a single column or a tuple, e.g.:</p>
            <div class="code-block">
                <pre>ORDER BY (toDate(time), name)
-- Good for: WHERE toDate(time) = '2024-01-15' or GROUP BY toDate(time), name</pre>
            </div>
            <p>Pick columns you often filter or group by (e.g. date, region, user_id).</p>

            <h3>PARTITION BY (optional)</h3>
            <p>You can split data into partitions so that old partitions can be dropped or moved. For time-series, a common choice is by month:</p>
            <div class="code-block">
                <pre>CREATE TABLE events (
  time DateTime,
  name String,
  value Float64
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(time)
ORDER BY time;</pre>
            </div>
            <p>Then all rows from January 2024 go in one partition, February in another, etc. Donâ€™t over-partition (e.g. by day for years of data can create too many parts).</p>

            <h3>Common data types</h3>
            <p>Choosing the right type saves space and speeds up queries. Here are the ones youâ€™ll use most:</p>
            <div class="diagram-box">
<pre>Type             Example values           Use case
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Int8/16/32/64    42, -100                 Counts, IDs (signed)
UInt8/16/32/64    0, 65535                 Counts, quantities (nonâ€‘negative)
Float32/64        3.14, -0.5               Prices, ratios
String            'hello'                  Names, IDs, text
Date              2024-01-15               Day only (no time)
DateTime          2024-01-15 14:30:00      Date + time
Nullable(Int64)   NULL or 42               When the column can be missing</pre>
            </div>
            <p>Use the smallest type that fits your data (e.g. <code>UInt8</code> for age 0â€“255, <code>Int32</code> for a 4-byte ID). <code>Nullable(...)</code> allows NULL in that column; use it only when you really need nulls, because it adds overhead.</p>

            <h3>Inserting data</h3>
            <p>You can insert with <code>VALUES</code> (a few rows) or with a format like TabSeparated for bulk load. Example:</p>
            <div class="code-block">
                <pre>INSERT INTO events (time, name, value) VALUES
  (now(), 'signup', 1.0),
  (now(), 'purchase', 29.99),
  (now() - INTERVAL 1 HOUR, 'click', 0.5);</pre>
            </div>
            <p>Then read them back:</p>
            <div class="code-block">
                <pre>SELECT * FROM events ORDER BY time DESC;</pre>
            </div>
            <div class="terminal-mock">
<pre><span class="output">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ time                â”‚ name     â”‚ value â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2024-02-14 13:00:00 â”‚ signup   â”‚   1   â”‚
â”‚ 2024-02-14 13:00:00 â”‚ purchase â”‚ 29.99 â”‚
â”‚ 2024-02-14 12:00:00 â”‚ click    â”‚  0.5  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜</span></pre>
            </div>

            <h3>Changing a table (ALTER)</h3>
            <p>You can add or drop columns without recreating the table:</p>
            <div class="code-block">
                <pre>ALTER TABLE events ADD COLUMN source String DEFAULT '';
ALTER TABLE events DROP COLUMN source;</pre>
            </div>
            <p>Add column is lightweight; drop column is also supported. For big schema changes, check the docs (e.g. modifying column type has limitations).</p>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Create MergeTree tables with <code>ENGINE = MergeTree()</code>, choose <code>ORDER BY</code> to match how you filter/group, optionally use <code>PARTITION BY</code> for time-series. Pick the smallest types that fit your data. Insert with <code>INSERT INTO ... VALUES</code> or bulk formats.</p>
            </div>
        </section>

        <!-- SQL Basics -->
        <section id="sql-basics" class="content-section">
            <h2>ğŸ”¤ SQL Basics</h2>
            <p>ClickHouse uses SQL. You write <code>SELECT ... FROM table WHERE ... ORDER BY ... LIMIT ...</code> and get results. This section builds from simple selects to filters, sorting, and limits so you can query your tables confidently.</p>

            <h3>SELECT and FROM</h3>
            <p><code>SELECT</code> lists the columns (or expressions) you want. <code>FROM</code> is the table name. The simplest query returns all columns and all rows:</p>
            <div class="code-block">
                <pre>SELECT * FROM events;</pre>
            </div>
            <p>To return only some columns and give one an alias:</p>
            <div class="code-block">
                <pre>SELECT time, name, value * 2 AS double_value
FROM events;</pre>
            </div>
            <p>You can use expressions: <code>value * 2</code>, <code>toDate(time)</code>, <code>upper(name)</code>, etc. <code>AS double_value</code> names the result column.</p>

            <h3>WHERE â€“ filtering rows</h3>
            <p><code>WHERE</code> keeps only rows that satisfy a condition. Use comparison and logical operators:</p>
            <div class="code-block">
                <pre>SELECT * FROM events
WHERE time >= now() - INTERVAL 1 DAY
  AND name = 'purchase';</pre>
            </div>
            <p>Common patterns:</p>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li><code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
                <li><code>name IN ('click', 'signup')</code> â€“ value in a list</li>
                <li><code>name LIKE '%click%'</code> â€“ pattern match (<code>%</code> = any characters)</li>
                <li><code>AND</code>, <code>OR</code>, <code>NOT</code> to combine conditions</li>
            </ul>
            <p>Filtering by columns that appear in your <code>ORDER BY</code> (e.g. <code>time</code>) lets ClickHouse skip data efficiently.</p>

            <h3>ORDER BY and LIMIT</h3>
            <p><code>ORDER BY column</code> sorts the result. Add <code>DESC</code> for descending:</p>
            <div class="code-block">
                <pre>SELECT * FROM events
ORDER BY time DESC
LIMIT 10;</pre>
            </div>
            <p><code>LIMIT 10</code> returns only the first 10 rows. Very useful for â€œtop Nâ€ or â€œlast Nâ€ without scanning the whole table.</p>

            <h3>Example: list recent events of one type</h3>
            <p>â€œShow me the last 20 purchase events, newest first.â€</p>
            <div class="code-block">
                <pre>SELECT time, name, value
FROM events
WHERE name = 'purchase'
ORDER BY time DESC
LIMIT 20;</pre>
            </div>

            <h3>Example: top event types by total value (last day)</h3>
            <p>â€œWhat were my top event types by total value in the last 24 hours?â€ This uses <code>GROUP BY</code> and <code>sum()</code> (weâ€™ll cover aggregations next); the structure is the same:</p>
            <div class="code-block">
                <pre>SELECT name, sum(value) AS total
FROM events
WHERE time >= now() - INTERVAL 1 DAY
GROUP BY name
ORDER BY total DESC
LIMIT 10;</pre>
            </div>
            <p><strong>What each part does:</strong> <code>WHERE</code> keeps only the last day. <code>GROUP BY name</code> puts all rows with the same <code>name</code> into one group. <code>sum(value)</code> adds up <code>value</code> in each group. <code>ORDER BY total DESC</code> sorts by that sum, biggest first. <code>LIMIT 10</code> returns the top 10.</p>
            <div class="terminal-mock">
<pre><span class="output">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ name     â”‚ total  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ purchase â”‚ 459.80 â”‚
â”‚ click    â”‚ 120.50 â”‚
â”‚ signup   â”‚  85.00 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></pre>
            </div>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Use <code>SELECT columns FROM table</code>, then <code>WHERE</code> to filter, <code>ORDER BY</code> to sort, and <code>LIMIT</code> to cap rows. Filter by the sort key when you can for best performance.</p>
            </div>
        </section>

        <!-- Aggregations -->
        <section id="aggregations" class="content-section">
            <h2>ğŸ“Š Aggregations</h2>
            <p>Aggregations turn many rows into one (or one per group): â€œtotal revenue,â€ â€œnumber of events,â€ â€œaverage value.â€ ClickHouse is built for this: <code>sum</code>, <code>count</code>, <code>avg</code>, <code>min</code>, <code>max</code>, and more run very fast over billions of rows because data is stored by column. This section teaches you how to use them with <code>GROUP BY</code> and <code>HAVING</code>.</p>

            <h3>What is aggregation?</h3>
            <p>An <strong>aggregate function</strong> takes many values and returns one: <code>sum(revenue)</code> â†’ total, <code>count()</code> â†’ number of rows, <code>avg(value)</code> â†’ average. If you use an aggregate without <code>GROUP BY</code>, you get one row for the whole table. With <code>GROUP BY column</code>, you get one row per distinct value of <code>column</code>.</p>

            <h3>GROUP BY</h3>
            <p><code>GROUP BY</code> splits rows into groups (e.g. by date, by product). Every column in <code>SELECT</code> must either be in <code>GROUP BY</code> or inside an aggregate function. Example:</p>
            <div class="code-block">
                <pre>SELECT name, count() AS cnt, sum(value) AS total
FROM events
WHERE time >= now() - INTERVAL 7 DAY
GROUP BY name
ORDER BY total DESC;</pre>
            </div>
            <p>Here we get one row per <code>name</code>, with the count of rows and the sum of <code>value</code> for that name.</p>

            <h3>Basic aggregate functions</h3>
            <ul style="margin-left: 22px; line-height: 1.9;">
                <li><code>count()</code> â€“ number of rows (no argument, or <code>count(column)</code> counts non-null values).</li>
                <li><code>sum(column)</code> â€“ sum of values.</li>
                <li><code>avg(column)</code> â€“ average.</li>
                <li><code>min(column)</code>, <code>max(column)</code> â€“ smallest and largest value.</li>
            </ul>

            <h3>Useful ClickHouse aggregates</h3>
            <ul style="margin-left: 22px; line-height: 1.9;">
                <li><code>uniq(column)</code> â€“ approximate count of distinct values (fast, very accurate).</li>
                <li><code>uniqExact(column)</code> â€“ exact count of distinct values (slower on huge data).</li>
                <li><code>quantile(0.5)(column)</code> â€“ median; <code>quantile(0.99)(column)</code> â€“ 99th percentile.</li>
                <li><code>argMax(value, key)</code> â€“ the <code>value</code> that corresponds to the maximum <code>key</code> (e.g. â€œname of the user with max revenueâ€).</li>
            </ul>

            <h3>HAVING â€“ filter after aggregation</h3>
            <p><code>WHERE</code> filters rows <em>before</em> aggregation. <code>HAVING</code> filters groups <em>after</em> aggregation. Example: â€œonly groups where total &gt; 100â€:</p>
            <div class="code-block">
                <pre>SELECT name, sum(value) AS total
FROM events
GROUP BY name
HAVING total > 100
ORDER BY total DESC;</pre>
            </div>

            <h3>Example: daily summary</h3>
            <p>â€œPer day, how many rows, total value, and average value?â€ (assuming you have an <code>events</code> table with <code>time</code> and <code>value</code>.)</p>
            <div class="code-block">
                <pre>SELECT
  toDate(time) AS day,
  count() AS row_count,
  sum(value) AS total_revenue,
  avg(value) AS avg_revenue
FROM events
WHERE time >= today() - 7
GROUP BY day
ORDER BY day;</pre>
            </div>

            <h3>Example: top 5 event types by count</h3>
            <p>â€œWhich event types had the most rows in the last day?â€</p>
            <div class="code-block">
                <pre>SELECT name, count() AS cnt
FROM events
WHERE time >= now() - INTERVAL 1 DAY
GROUP BY name
ORDER BY cnt DESC
LIMIT 5;</pre>
            </div>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Use <code>GROUP BY</code> to get one row per group; combine it with <code>sum()</code>, <code>count()</code>, <code>avg()</code>, etc. Use <code>HAVING</code> to filter by aggregate results. <code>uniq()</code> and <code>quantile()</code> are especially useful in analytics.</p>
            </div>
        </section>

        <!-- Window Functions -->
        <section id="window-functions" class="content-section">
            <h2>ğŸªŸ Window Functions</h2>
            <p>Window functions let you compute something <strong>per row</strong> while looking at a â€œwindowâ€ of related rows â€“ for example â€œrank within each day,â€ â€œrunning total so far,â€ or â€œprevious rowâ€™s value.â€ They are powerful for rankings, trends, and time-series analysis.</p>

            <h3>What is a window?</h3>
            <p>A window is defined by:</p>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li><code>PARTITION BY</code> â€“ split rows into groups (e.g. by date, by user). The function is computed inside each group.</li>
                <li><code>ORDER BY</code> â€“ order of rows inside the partition (e.g. by time, by revenue).</li>
            </ul>
            <p>So â€œfor each row, consider only rows in the same partition, in this order.â€</p>

            <h3>ROW_NUMBER, RANK, DENSE_RANK</h3>
            <p>These assign a number to each row within the partition:</p>
            <ul style="margin-left: 22px; line-height: 1.8;">
                <li><code>row_number()</code> â€“ 1, 2, 3, â€¦ (unique per row).</li>
                <li><code>rank()</code> â€“ same value for ties, then skip (1, 2, 2, 4).</li>
                <li><code>dense_rank()</code> â€“ same value for ties, no skip (1, 2, 2, 3).</li>
            </ul>
            <p>Example: rank products by revenue within each day.</p>
            <div class="code-block">
                <pre>SELECT
  sale_date,
  product,
  revenue,
  row_number() OVER (PARTITION BY sale_date ORDER BY revenue DESC) AS rank
FROM sales
WHERE sale_date = today() - 1
ORDER BY sale_date, rank;</pre>
            </div>
            <p><strong>What this does:</strong> <code>PARTITION BY sale_date</code> means â€œper day.â€ <code>ORDER BY revenue DESC</code> means â€œbest revenue first.â€ <code>row_number()</code> assigns 1 to the top product that day, 2 to the second, and so on.</p>

            <h3>LAG and LEAD</h3>
            <p><code>LAG(column)</code> = value of <code>column</code> from the <strong>previous</strong> row (in the window order). <code>LEAD(column)</code> = value from the <strong>next</strong> row. Useful for â€œcompare to previousâ€ or â€œnext value.â€</p>
            <div class="code-block">
                <pre>SELECT
  time,
  value,
  LAG(value) OVER (ORDER BY time) AS prev_value,
  value - LAG(value) OVER (ORDER BY time) AS diff_from_prev
FROM events
ORDER BY time;</pre>
            </div>
            <p>Here <code>prev_value</code> is the previous rowâ€™s <code>value</code>, and <code>diff_from_prev</code> is the change. You can use <code>LAG(value, 2)</code> to look two rows back.</p>

            <h3>Running sum (cumulative total)</h3>
            <p>Use <code>sum(...) OVER (ORDER BY ...)</code> to get a running total:</p>
            <div class="code-block">
                <pre>SELECT
  time,
  value,
  sum(value) OVER (ORDER BY time) AS running_total
FROM events
ORDER BY time;</pre>
            </div>
            <p>Each rowâ€™s <code>running_total</code> is the sum of <code>value</code> from the first row up to that row.</p>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Window functions use <code>OVER (PARTITION BY ... ORDER BY ...)</code>. Use <code>row_number()</code> for rankings, <code>LAG</code>/<code>LEAD</code> for previous/next value, and <code>sum() OVER (ORDER BY ...)</code> for running totals.</p>
            </div>
        </section>

        <!-- Real-time & Integrations -->
        <section id="realtime-integrations" class="content-section">
            <h2>ğŸ”Œ Real-time and Integrations</h2>
            <p>ClickHouse can ingest data in real time (HTTP, native protocol, or Kafka) and power dashboards, APIs, and data pipelines. This section shows you the main ways to get data in and connect ClickHouse to the rest of your stack.</p>

            <h3>Inserting data via HTTP</h3>
            <p>The HTTP interface (port 8123) accepts INSERTs. You send the query in the URL and the data in the body. Any language that can do HTTP POST can insert rows. Example with <code>curl</code> using TabSeparated format (columns separated by tab, rows by newline):</p>
            <div class="code-block">
                <pre>echo -e "2024-02-14 12:00:00\tpage_view\t1.0\n2024-02-14 12:01:00\tclick\t0.5" \
  | curl -X POST 'http://localhost:8123/?query=INSERT%20INTO%20events%20FORMAT%20TabSeparated' --data-binary @-</pre>
            </div>
            <p>From Python you can use the <code>clickhouse-driver</code> or <code>clickhouse-connect</code> library, or plain HTTP with <code>requests</code>. For very high throughput, use the <strong>native protocol</strong> (port 9000) instead of HTTP.</p>

            <h3>Using the clickhouse-client for bulk load</h3>
            <p>For loading files (CSV, Parquet, etc.), you can pipe data into the client:</p>
            <div class="code-block">
                <pre>clickhouse-client --host localhost --query "INSERT INTO events FORMAT TabSeparated" < data.tsv</pre>
            </div>
            <p>Or from inside the Docker container:</p>
            <div class="code-block">
                <pre>docker exec -i clickhouse-server clickhouse-client --query "INSERT INTO events FORMAT TabSeparated" < data.tsv</pre>
            </div>
            <p>Supported formats include TabSeparated, CSV, JSONEachRow, Parquet. Choose the one that matches your file.</p>

            <h3>Kafka and streaming (concept)</h3>
            <p>ClickHouse can read directly from Apache Kafka using a <strong>Kafka table engine</strong>: you define a table that reads from a Kafka topic, and optionally a materialized view that writes from that table into a MergeTree table. That way, events flowing into Kafka are continuously ingested into ClickHouse. Setting this up requires Kafka and some configuration; the docs have step-by-step examples. For learning, start with HTTP or client inserts; add Kafka once you need real-time streaming.</p>

            <h3>Materialized views (concept)</h3>
            <p>A <strong>materialized view</strong> in ClickHouse is a trigger: whenever data is inserted into a source table, a query runs and its result is written into the materialized viewâ€™s underlying table. So you can keep a â€œpre-aggregatedâ€ table (e.g. â€œdaily totals per event typeâ€) that updates automatically as new rows arrive. Useful for dashboards that need fast answers over large tables.</p>

            <h3>Dashboards and BI tools</h3>
            <p>Connect ClickHouse to your favorite tool and run SQL to build charts:</p>
            <ul style="margin-left: 22px; line-height: 1.9;">
                <li><strong>Grafana</strong> â€“ add ClickHouse as a data source (plugin available), write SQL in the panel editor.</li>
                <li><strong>Metabase / Apache Superset</strong> â€“ add ClickHouse (HTTP or native), create questions/queries with the UI or raw SQL.</li>
            </ul>
            <p>All of them ultimately run SELECT queries; your job is to write efficient SQL (filter by sort key, use aggregations).</p>

            <h3>Pipelines: Airflow, dbt</h3>
            <p><strong>Airflow:</strong> Use a <code>ClickHouseHook</code> or a task that runs <code>clickhouse-client</code> or sends HTTP requests to run ETL (e.g. â€œevery hour, insert from S3 into ClickHouseâ€). <strong>dbt:</strong> Use the dbt-clickhouse adapter to define models (SQL) that build and transform tables in ClickHouse. Good for â€œraw table â†’ cleaned table â†’ aggregated tableâ€ workflows.</p>

            <div class="key-takeaway">
                <h4>Key takeaway</h4>
                <p>Insert via HTTP (any app), clickhouse-client (bulk load), or Kafka (streaming). Use Grafana/Metabase/Superset for dashboards; use Airflow/dbt for scheduled pipelines. Start simple with HTTP inserts and SELECTs, then add streaming and materialized views as needed.</p>
            </div>

            <h3>Whatâ€™s next?</h3>
            <p>You now have a full path: install â†’ create tables â†’ query with SQL â†’ aggregate and use windows â†’ plug into dashboards and pipelines. Practice by building a small project: e.g. a table of events (time, name, value), insert some rows, then write queries for â€œtotals per day,â€ â€œtop 10 event types,â€ and a running sum. Use the official <a href="https://clickhouse.com/docs" target="_blank" rel="noopener">ClickHouse docs</a> for reference and advanced features (replication, clusters, more table engines). Have fun with it.</p>
        </section>
    </main>

    <script>
        function showSection(id) {
            document.querySelectorAll('.content-section').forEach(function(s) { s.classList.remove('active'); });
            var el = document.getElementById(id);
            if (el) el.classList.add('active');
        }
    </script>
    <script src="../js/code-copy.js"></script>
</body>
</html>
